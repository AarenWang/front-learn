# L10 - 异步与并发类型

## 本课时目标
- 理解 TypeScript 中的异步类型系统
- 掌握 Promise 和 async/await 的类型推断
- 学会处理并发操作的类型问题
- 实现一个类型安全的批处理调度器

## 1. Promise 类型系统

### 1.1 基础 Promise 类型

```typescript
// Promise 的基础类型定义
// Promise<T> 表示一个可能持有 T 类型值的异步操作

// 基础 Promise 使用
function fetchUser(id: string): Promise<User> {
  return fetch(`/api/users/${id}`)
    .then(response => response.json());
}

// Promise 的类型推断
const userPromise = fetchUser('123'); // Promise<User>

// Promise 的状态类型
type PromiseState<T> = 
  | { status: 'pending' }
  | { status: 'fulfilled'; value: T }
  | { status: 'rejected'; reason: any };

// 包装 Promise 以跟踪状态
class TrackedPromise<T> implements PromiseLike<T> {
  private state: PromiseState<T>;
  private promise: Promise<T>;
  
  constructor(promise: Promise<T>) {
    this.state = { status: 'pending' };
    this.promise = promise.then(
      value => {
        this.state = { status: 'fulfilled', value };
        return value;
      },
      reason => {
        this.state = { status: 'rejected', reason };
        throw reason;
      }
    );
  }
  
  getState(): PromiseState<T> {
    return this.state;
  }
  
  then<TResult1 = T, TResult2 = never>(
    onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
    onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): Promise<TResult1 | TResult2> {
    return this.promise.then(onFulfilled, onRejected);
  }
  
  catch<TResult = never>(
    onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null
  ): Promise<T | TResult> {
    return this.promise.catch(onRejected);
  }
}

// 使用
const trackedUser = new TrackedPromise(fetchUser('123'));
console.log(trackedUser.getState()); // { status: 'pending' }
```

### 1.2 Promise 工具类型

```typescript
// Awaited 类型（TypeScript 4.5+）
type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;

// 手动实现 Awaited（适用于旧版本）
type MyAwaited<T> = T extends Promise<infer U> ? U : T;

// 使用示例
type User = Awaited<Promise<User>>; // User
type StringArray = Awaited<Promise<string[]>>; // string[]
type NestedPromise = Awaited<Promise<Promise<number>>>; // number

// PromiseReturn 类型 - 提取函数返回的 Promise 解析类型
type PromiseReturn<T> = T extends (...args: any[]) => Promise<infer U> 
  ? U 
  : never;

type GetUserReturn = PromiseReturn<typeof fetchUser>; // User

// PromiseArray 类型 - Promise 数组的解包
type PromiseArray<T> = T extends Promise<infer U>[] 
  ? U[] 
  : never;

type Users = PromiseArray<Promise<User>[]>; // User[]

// FirstPromise 类型 - Promise 数组中第一个成功的值
type FirstPromise<T extends Promise<any>[]> = T extends [infer First, ...infer Rest]
  ? First extends Promise<infer U>
    ? Awaited<First>
    : never
  : never;

// PromiseUnion 类型 - Promise 联合类型的解包
type PromiseUnion<T> = T extends Promise<infer U> 
  ? U 
  : never;

type Result = PromiseUnion<Promise<string> | Promise<number>>; // string | number
```

### 1.3 Promise 组合模式

```typescript
// Promise.all 的类型安全使用
async function fetchMultipleUsers(ids: string[]): Promise<User[]> {
  const promises = ids.map(id => fetchUser(id));
  const users = await Promise.all(promises);
  return users;
}

// Promise.allSettled 的类型处理
async function fetchUsersWithResults(ids: string[]): Promise<Array<{
  id: string;
  user?: User;
  error?: Error;
}>> {
  const promises = ids.map(async (id) => {
    try {
      const user = await fetchUser(id);
      return { id, user };
    } catch (error) {
      return { id, error: error as Error };
    }
  });
  
  return Promise.all(promises);
}

// Promise.race 的类型包装
function raceWithTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number
): Promise<T> {
  const timeout = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), timeoutMs);
  });
  
  return Promise.race([promise, timeout]);
}

// 使用
const user = await raceWithTimeout(fetchUser('123'), 5000);

// Promise.any 的类型处理（ES2021+）
async function fetchFirstSuccessfulUser(ids: string[]): Promise<User> {
  const promises = ids.map(id => fetchUser(id));
  return Promise.any(promises); // 返回第一个成功的 User
}
```

## 2. async/await 类型推断

### 2.1 函数返回类型推断

```typescript
// async 函数自动返回 Promise 类型
async function getUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

// TypeScript 自动推断返回类型
async function getUserName(id: string) { // 推断为 Promise<string>
  const user = await getUser(id);
  return user.name;
}

// 条件返回的 async 函数
async function findUserOrThrow(id: string): Promise<User> {
  const user = await getUser(id);
  if (!user) {
    throw new Error('User not found');
  }
  return user;
}

// 异步函数重载
async function fetchUserData<T>(id: string): Promise<T>;
async function fetchUserData<T>(ids: string[]): Promise<T[]>;
async function fetchUserData<T>(input: string | string[]): Promise<T | T[]> {
  if (Array.isArray(input)) {
    const promises = input.map(id => fetchUserData<T>(id));
    return Promise.all(promises) as Promise<T[]>;
  } else {
    const response = await fetch(`/api/data/${input}`);
    return response.json();
  }
}
```

### 2.2 错误处理类型

```typescript
// 错误类型的定义
class NetworkError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public url: string
  ) {
    super(message);
  }
}

class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public value: any
  ) {
    super(message);
  }
}

// 类型安全的错误处理
async function safeFetchUser(id: string): Promise<
  { success: true; data: User } | 
  { success: false; error: NetworkError | ValidationError }
> {
  try {
    const user = await fetchUser(id);
    return { success: true, data: user };
  } catch (error) {
    if (error instanceof NetworkError) {
      return { success: false, error };
    } else if (error instanceof ValidationError) {
      return { success: false, error };
    }
    throw error;
  }
}

// 使用类型守卫处理结果
function isNetworkError(error: any): error is NetworkError {
  return error instanceof NetworkError;
}

function isValidationError(error: any): error is ValidationError {
  return error instanceof ValidationError;
}

async function demonstrateErrorHandling() {
  const result = await safeFetchUser('123');
  
  if (result.success) {
    console.log('User:', result.data.name);
  } else {
    if (isNetworkError(result.error)) {
      console.log(`Network error: ${result.error.message} (${result.error.statusCode})`);
    } else if (isValidationError(result.error)) {
      console.log(`Validation error in field ${result.error.field}: ${result.error.message}`);
    }
  }
}
```

### 2.3 并发操作类型

```typescript
// 并发控制接口
interface ConcurrencyOptions {
  maxConcurrency?: number;
  delay?: number;
  retryAttempts?: number;
  retryDelay?: number;
}

// 并发执行器
class ConcurrencyExecutor<TInput, TResult> {
  private queue: Array<{
    input: TInput;
    resolve: (result: TResult) => void;
    reject: (error: any) => void;
  }> = [];
  
  private running = 0;
  
  constructor(
    private executor: (input: TInput) => Promise<TResult>,
    private options: ConcurrencyOptions = {}
  ) {}
  
  async execute(inputs: TInput[]): Promise<TResult[]> {
    const promises = inputs.map(input => this.addToQueue(input));
    return Promise.all(promises);
  }
  
  private async addToQueue(input: TInput): Promise<TResult> {
    return new Promise<TResult>((resolve, reject) => {
      this.queue.push({ input, resolve, reject });
      this.process();
    });
  }
  
  private async process(): Promise<void> {
    const maxConcurrency = this.options.maxConcurrency || 3;
    
    if (this.running >= maxConcurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { input, resolve, reject } = this.queue.shift()!;
    
    try {
      const result = await this.executeWithRetry(input);
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
  
  private async executeWithRetry(input: TInput): Promise<TResult> {
    const maxAttempts = this.options.retryAttempts || 0;
    let lastError: any;
    
    for (let attempt = 0; attempt <= maxAttempts; attempt++) {
      try {
        if (attempt > 0 && this.options.delay) {
          await this.delay(this.options.delay);
        }
        
        return await this.executor(input);
      } catch (error) {
        lastError = error;
        
        if (attempt < maxAttempts && this.options.retryDelay) {
          await this.delay(this.options.retryDelay);
        }
      }
    }
    
    throw lastError;
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// 使用示例
async function fetchUserWithTimeout(id: string): Promise<User> {
  const executor = new ConcurrencyExecutor(fetchUser, {
    maxConcurrency: 5,
    retryAttempts: 2,
    retryDelay: 1000
  });
  
  const [user] = await executor.execute([id]);
  return user;
}
```

## 3. 流式类型处理

### 3.1 Observable 类型模式

```typescript
// Observable 类型定义
interface Observable<T> {
  subscribe(observer: Observer<T>): Subscription;
}

interface Observer<T> {
  next: (value: T) => void;
  error?: (error: any) => void;
  complete?: () => void;
}

interface Subscription {
  unsubscribe(): void;
}

// 简单的 Observable 实现
class SimpleObservable<T> implements Observable<T> {
  private observers: Observer<T>[] = [];
  private isCompleted = false;
  
  constructor(
    private producer: (observer: Observer<T>) => void | (() => void)
  ) {}
  
  subscribe(observer: Observer<T>): Subscription {
    this.observers.push(observer);
    
    const cleanup = this.producer(observer);
    
    return {
      unsubscribe: () => {
        const index = this.observers.indexOf(observer);
        if (index > -1) {
          this.observers.splice(index, 1);
        }
        cleanup?.();
      }
    };
  }
  
  private notify(value: T): void {
    if (this.isCompleted) return;
    
    for (const observer of this.observers) {
      observer.next(value);
    }
  }
  
  private error(error: any): void {
    if (this.isCompleted) return;
    
    for (const observer of this.observers) {
      observer.error?.(error);
    }
    this.observers = [];
  }
  
  private complete(): void {
    if (this.isCompleted) return;
    
    for (const observer of this.observers) {
      observer.complete?.();
    }
    this.observers = [];
    this.isCompleted = true;
  }
}

// Observable 工厂函数
function of<T>(...values: T[]): Observable<T> {
  return new SimpleObservable(observer => {
    values.forEach(value => observer.next(value));
    observer.complete?.();
  });
}

function fromPromise<T>(promise: Promise<T>): Observable<T> {
  return new SimpleObservable(observer => {
    promise
      .then(value => {
        observer.next(value);
        observer.complete?.();
      })
      .catch(error => observer.error?.(error));
  });
}

function interval(ms: number): Observable<number> {
  return new SimpleObservable(observer => {
    let count = 0;
    const intervalId = setInterval(() => {
      observer.next(count++);
    }, ms);
    
    return () => clearInterval(intervalId);
  });
}

// Observable 操作符类型
type Operator<T, R> = (source: Observable<T>) => Observable<R>;

function map<T, R>(fn: (value: T) => R): Operator<T, R> {
  return (source) => new SimpleObservable(observer => {
    return source.subscribe({
      next: (value) => observer.next(fn(value)),
      error: (error) => observer.error?.(error),
      complete: () => observer.complete?.()
    });
  });
}

function filter<T>(predicate: (value: T) => boolean): Operator<T, T> {
  return (source) => new SimpleObservable(observer => {
    return source.subscribe({
      next: (value) => {
        if (predicate(value)) {
          observer.next(value);
        }
      },
      error: (error) => observer.error?.(error),
      complete: () => observer.complete?.()
    });
  });
}
```

### 3.2 异步迭代器

```typescript
// 异步迭代器类型定义
interface AsyncIterator<T, TReturn = any, TNext = undefined> {
  next(...args: [] | [TNext]): Promise<IteratorResult<T, TReturn>>;
  return?(value?: TReturn): Promise<IteratorResult<T, TReturn>>;
  throw?(e?: any): Promise<IteratorResult<T, TReturn>>;
}

interface AsyncIterable<T> {
  [Symbol.asyncIterator](): AsyncIterator<T>;
}

// 异步迭代器的实现
class AsyncRange implements AsyncIterable<number> {
  constructor(
    private start: number,
    private end: number,
    private step: number = 1
  ) {}
  
  [Symbol.asyncIterator](): AsyncIterator<number> {
    let current = this.start;
    
    return {
      next: async () => {
        if (current > this.end) {
          return { done: true, value: undefined };
        }
        
        const value = current;
        current += this.step;
        
        // 模拟异步操作
        await new Promise(resolve => setTimeout(resolve, 100));
        
        return { done: false, value };
      }
    };
  }
}

// 使用异步迭代器
async function demonstrateAsyncIterator() {
  const range = new AsyncRange(1, 5);
  
  for await (const num of range) {
    console.log('Number:', num);
  }
}

// 异步生成器函数
async function* fetchUsersPaginated(
  pageSize: number = 10
): AsyncGenerator<User, void, unknown> {
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const response = await fetch(`/api/users?page=${page}&limit=${pageSize}`);
    const { data, pagination } = await response.json();
    
    for (const user of data) {
      yield user;
    }
    
    hasMore = pagination.hasNext;
    page++;
  }
}

// 使用异步生成器
async function processAllUsers() {
  for await (const user of fetchUsersPaginated(50)) {
    console.log('Processing user:', user.name);
    // 处理用户数据
  }
}
```

## 4. 实战：批处理调度器

### 4.1 需求分析

创建一个类型安全的批处理调度器，支持：
- 批量操作合并
- 防抖和节流
- 优先级队列
- 并发控制

### 4.2 批处理调度器核心

```typescript
// 批处理任务接口
interface BatchTask<TInput, TResult> {
  id: string;
  input: TInput;
  resolve: (result: TResult) => void;
  reject: (error: any) => void;
  timestamp: number;
  priority?: number;
}

// 批处理选项
interface BatchOptions {
  batchSize?: number;
  delay?: number;
  maxWait?: number;
  maxConcurrency?: number;
  priority?: boolean;
}

// 批处理器接口
interface BatchProcessor<TInput, TResult> {
  process(inputs: TInput[]): Promise<TResult[]>;
}

// 批处理调度器类
class BatchScheduler<TInput, TResult> {
  private tasks: BatchTask<TInput, TResult>[] = [];
  private processing = false;
  private timer?: NodeJS.Timeout;
  
  constructor(
    private processor: BatchProcessor<TInput, TResult>,
    private options: BatchOptions = {}
  ) {}
  
  // 添加任务
  async schedule(input: TInput, priority?: number): Promise<TResult> {
    return new Promise<TResult>((resolve, reject) => {
      const task: BatchTask<TInput, TResult> = {
        id: this.generateId(),
        input,
        resolve,
        reject,
        timestamp: Date.now(),
        priority
      };
      
      this.addTask(task);
      this.scheduleProcessing();
    });
  }
  
  // 添加任务到队列
  private addTask(task: BatchTask<TInput, TResult>): void {
    if (this.options.priority && task.priority !== undefined) {
      // 优先级队列 - 按优先级插入
      const insertIndex = this.tasks.findIndex(
        t => (t.priority || 0) < task.priority!
      );
      if (insertIndex === -1) {
        this.tasks.push(task);
      } else {
        this.tasks.splice(insertIndex, 0, task);
      }
    } else {
      // 普通队列 - FIFO
      this.tasks.push(task);
    }
  }
  
  // 调度处理
  private scheduleProcessing(): void {
    const batchSize = this.options.batchSize || 10;
    const delay = this.options.delay || 100;
    const maxWait = this.options.maxWait || 1000;
    
    if (this.tasks.length >= batchSize) {
      this.processTasks();
      return;
    }
    
    if (this.timer) {
      clearTimeout(this.timer);
    }
    
    this.timer = setTimeout(() => {
      this.processTasks();
    }, delay);
    
    // 设置最大等待时间
    setTimeout(() => {
      if (this.tasks.length > 0) {
        this.processTasks();
      }
    }, maxWait);
  }
  
  // 处理任务批次
  private async processTasks(): Promise<void> {
    if (this.processing || this.tasks.length === 0) {
      return;
    }
    
    this.processing = true;
    
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = undefined;
    }
    
    const batchSize = this.options.batchSize || 10;
    const batch = this.tasks.splice(0, batchSize);
    
    try {
      const inputs = batch.map(task => task.input);
      const results = await this.processor.process(inputs);
      
      // 匹配结果与任务
      batch.forEach((task, index) => {
        const result = results[index];
        if (result instanceof Error) {
          task.reject(result);
        } else {
          task.resolve(result);
        }
      });
      
    } catch (error) {
      // 如果整个批处理失败，拒绝所有任务
      batch.forEach(task => task.reject(error));
    } finally {
      this.processing = false;
      
      // 如果还有任务，继续处理
      if (this.tasks.length > 0) {
        this.scheduleProcessing();
      }
    }
  }
  
  // 生成唯一 ID
  private generateId(): string {
    return `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // 获取状态
  getStatus(): {
    pendingTasks: number;
    processing: boolean;
    oldestTaskAge?: number;
  } {
    const oldestTask = this.tasks[0];
    return {
      pendingTasks: this.tasks.length,
      processing: this.processing,
      oldestTaskAge: oldestTask ? Date.now() - oldestTask.timestamp : undefined
    };
  }
  
  // 清理
  destroy(): void {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    
    // 拒绝所有待处理任务
    this.tasks.forEach(task => {
      task.reject(new Error('Scheduler destroyed'));
    });
    
    this.tasks = [];
  }
}
```

### 4.3 具体批处理器实现

```typescript
// API 批处理器
class ApiBatchProcessor<TInput, TResult> implements BatchProcessor<TInput, TResult> {
  constructor(
    private endpoint: string,
    private inputMapper: (input: TInput) => any,
    private resultMapper: (result: any, index: number) => TResult
  ) {}
  
  async process(inputs: TInput[]): Promise<TResult[]> {
    try {
      const payload = inputs.map(this.inputMapper);
      
      const response = await fetch(this.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ requests: payload })
      });
      
      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`);
      }
      
      const batchResponse = await response.json();
      return batchResponse.results.map(this.resultMapper);
      
    } catch (error) {
      console.error('Batch processing failed:', error);
      throw error;
    }
  }
}

// 数据库批处理器
class DatabaseBatchProcessor<TInput, TResult> implements BatchProcessor<TInput, TResult> {
  constructor(
    private query: string,
    private inputMapper: (input: TInput) => any[],
    private resultMapper: (row: any, index: number) => TResult
  ) {}
  
  async process(inputs: TInput[]): Promise<TResult[]> {
    // 模拟数据库批处理操作
    const params = inputs.flatMap(this.inputMapper);
    
    // 这里应该是实际的数据库查询
    // const results = await db.query(query, params);
    
    // 模拟结果
    return inputs.map((input, index) => 
      this.resultMapper({ id: index + 1, ...input }, index)
    );
  }
}
```

### 4.4 高级功能扩展

```typescript
// 智能批处理器 - 根据负载调整批次大小
class SmartBatchScheduler<TInput, TResult> extends BatchScheduler<TInput, TResult> {
  private avgProcessingTime = 0;
  private processingTimes: number[] = [];
  private adaptiveBatchSize: number;
  
  constructor(
    processor: BatchProcessor<TInput, TResult>,
    options: BatchOptions = {}
  ) {
    super(processor, options);
    this.adaptiveBatchSize = options.batchSize || 10;
  }
  
  protected async processTasks(): Promise<void> {
    if (this.processing || this.tasks.length === 0) {
      return;
    }
    
    this.processing = true;
    
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = undefined;
    }
    
    const startTime = Date.now();
    const batch = this.tasks.splice(0, this.adaptiveBatchSize);
    
    try {
      const inputs = batch.map(task => task.input);
      const results = await this.processor.process(inputs);
      
      batch.forEach((task, index) => {
        const result = results[index];
        if (result instanceof Error) {
          task.reject(result);
        } else {
          task.resolve(result);
        }
      });
      
    } catch (error) {
      batch.forEach(task => task.reject(error));
    } finally {
      const processingTime = Date.now() - startTime;
      this.updateMetrics(processingTime);
      
      this.processing = false;
      
      if (this.tasks.length > 0) {
        this.scheduleProcessing();
      }
    }
  }
  
  private updateMetrics(processingTime: number): void {
    this.processingTimes.push(processingTime);
    
    // 保持最近 50 次处理的记录
    if (this.processingTimes.length > 50) {
      this.processingTimes.shift();
    }
    
    // 计算平均处理时间
    this.avgProcessingTime = 
      this.processingTimes.reduce((sum, time) => sum + time, 0) / this.processingTimes.length;
    
    // 调整批次大小
    this.adjustBatchSize();
  }
  
  private adjustBatchSize(): void {
    const targetTime = 1000; // 目标处理时间 1 秒
    const currentBatchSize = this.adaptiveBatchSize;
    
    if (this.avgProcessingTime > targetTime) {
      // 处理时间太长，减少批次大小
      this.adaptiveBatchSize = Math.max(1, Math.floor(currentBatchSize * 0.8));
    } else if (this.avgProcessingTime < targetTime * 0.5) {
      // 处理时间太短，增加批次大小
      this.adaptiveBatchSize = Math.min(50, Math.ceil(currentBatchSize * 1.2));
    }
  }
  
  getMetrics(): {
    avgProcessingTime: number;
    currentBatchSize: number;
    processingTimeHistory: number[];
  } {
    return {
      avgProcessingTime: this.avgProcessingTime,
      currentBatchSize: this.adaptiveBatchSize,
      processingTimeHistory: [...this.processingTimes]
    };
  }
}

// 带缓存的批处理器
class CachedBatchScheduler<TInput, TResult> extends BatchScheduler<TInput, TResult> {
  private cache = new Map<string, { result: TResult; timestamp: number }>();
  private cacheTTL: number;
  
  constructor(
    processor: BatchProcessor<TInput, TResult>,
    options: BatchOptions & { cacheTTL?: number } = {}
  ) {
    super(processor, options);
    this.cacheTTL = options.cacheTTL || 60000; // 默认 1 分钟
  }
  
  async schedule(input: TInput, key?: string): Promise<TResult> {
    if (key) {
      const cached = this.cache.get(key);
      if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
        return cached.result;
      }
    }
    
    const result = await super.schedule(input);
    
    if (key) {
      this.cache.set(key, { result, timestamp: Date.now() });
    }
    
    return result;
  }
  
  clearCache(): void {
    this.cache.clear();
  }
  
  clearExpiredCache(): void {
    const now = Date.now();
    for (const [key, cached] of this.cache.entries()) {
      if (now - cached.timestamp > this.cacheTTL) {
        this.cache.delete(key);
      }
    }
  }
}
```

### 4.5 使用示例

```typescript
// 定义数据类型
interface User {
  id: string;
  name: string;
  email: string;
}

interface UserLookupInput {
  userId: string;
}

// 创建用户查询批处理器
const userBatchProcessor = new ApiBatchProcessor<UserLookupInput, User>(
  '/api/users/batch',
  (input) => ({ userId: input.userId }),
  (result, index) => result.data
);

// 创建批处理调度器
const userScheduler = new SmartBatchScheduler(userBatchProcessor, {
  batchSize: 20,
  delay: 50,
  maxWait: 500,
  priority: true
});

// 使用调度器
async function demonstrateBatchScheduler() {
  const userIds = ['1', '2', '3', '4', '5'];
  
  // 并发请求多个用户
  const userPromises = userIds.map(id => 
    userScheduler.schedule({ userId: id }, parseInt(id))
  );
  
  const users = await Promise.all(userPromises);
  console.log('Fetched users:', users.map(u => u.name));
  
  // 获取调度器状态
  const status = userScheduler.getStatus();
  console.log('Scheduler status:', status);
  
  // 获取性能指标
  const metrics = userScheduler.getMetrics();
  console.log('Performance metrics:', metrics);
}

// 缓存批处理器示例
const cachedUserScheduler = new CachedBatchScheduler(userBatchProcessor, {
  batchSize: 15,
  delay: 100,
  cacheTTL: 30000 // 30 秒缓存
});

async function demonstrateCachedScheduler() {
  // 第一次请求
  const user1 = await cachedUserScheduler.schedule(
    { userId: '123' },
    'user_123'
  );
  
  // 第二次请求（从缓存获取）
  const user2 = await cachedUserScheduler.schedule(
    { userId: '123' },
    'user_123'
  );
  
  console.log('Same user from cache:', user1.name === user2.name);
}

// 工厂函数简化使用
function createBatchApi<TInput, TResult>(
  endpoint: string,
  inputMapper: (input: TInput) => any,
  resultMapper: (result: any, index: number) => TResult,
  options?: BatchOptions
) {
  const processor = new ApiBatchProcessor(endpoint, inputMapper, resultMapper);
  return new SmartBatchScheduler(processor, options);
}

// 使用工厂函数
const productBatchScheduler = createBatchApi(
  '/api/products/batch',
  (input: { productId: string }) => ({ productId: input.productId }),
  (result: any) => result.data,
  { batchSize: 15, delay: 75 }
);
```

## 5. 练习与作业

### 5.1 基础练习

1. **Promise 类型练习**
   ```typescript
   // 实现以下工具类型：
   // 1. UnwrapPromiseArray<T>
   // 2. FirstSuccessful<T>
   // 3. PromiseTuple<T>
   ```

2. **async/await 练习**
   ```typescript
   // 创建类型安全的异步函数：
   // 1. 重试机制装饰器
   // 2. 超时包装器
   // 3. 并发限制执行器
   ```

### 5.2 进阶练习

3. **流式处理练习**
   ```typescript
   // 实现：
   // 1. AsyncIterable 到 Observable 转换
   // 2. 防抖和节流的 Observable 操作符
   // 3. 错误重试机制
   ```

### 5.3 实战作业

4. **完整的批处理系统**
   - 实现分布式批处理
   - 添加持久化和恢复功能
   - 创建监控和指标收集
   - 实现动态负载均衡
   - 添加单元测试和集成测试

## 6. 最佳实践

### 6.1 异步类型设计原则

```typescript
// ✅ 明确的 Promise 类型注解
async function fetchUser(id: string): Promise<User> {
  // ...
}

// ✅ 使用类型安全的错误处理
async function safeOperation<T>(
  operation: () => Promise<T>
): Promise<{ success: true; data: T } | { success: false; error: Error }> {
  try {
    const data = await operation();
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}

// ✅ 合理使用 Awaited
type UserFromPromise = Awaited<Promise<User>>;

// ❌ 避免 Promise 中直接返回 Promise
async function bad(): Promise<Promise<string>> {
  return Promise.resolve('hello'); // 不必要的嵌套
}

// ✅ 正确的做法
async function good(): Promise<string> {
  return 'hello'; // 自动包装为 Promise<string>
}
```

### 6.2 并发控制原则

```typescript
// ✅ 控制并发数量
async function limitedConcurrency<T, R>(
  items: T[],
  fn: (item: T) => Promise<R>,
  limit: number = 3
): Promise<R[]> {
  const results: R[] = [];
  const executing: Promise<void>[] = [];
  
  for (const item of items) {
    const promise = fn(item).then(result => {
      results.push(result);
    });
    
    executing.push(promise);
    
    if (executing.length >= limit) {
      await Promise.race(executing);
      executing.splice(executing.findIndex(p => p === promise), 1);
    }
  }
  
  await Promise.all(executing);
  return results;
}

// ✅ 优雅的错误处理
async function withFallback<T>(
  primary: Promise<T>,
  fallback: () => Promise<T>
): Promise<T> {
  try {
    return await primary;
  } catch {
    return await fallback();
  }
}
```

## 7. 课程总结

### 7.1 核心知识点回顾

1. **Promise 类型系统**：Awaited 工具类型和组合模式
2. **async/await**：类型推断和错误处理
3. **流式处理**：Observable 和异步迭代器
4. **批处理调度器**：类型安全的并发控制

### 7.2 关键概念

- **类型推断**：TypeScript 自动推断异步函数返回类型
- **错误处理**：类型安全的错误传播和处理
- **并发控制**：限制同时执行的异步操作数量
- **批处理优化**：合并多个操作以提高效率

### 7.3 下节预告

下一课时将学习声明文件与第三方库，包括：
- DefinitelyTyped 和类型声明编写
- 模块声明和全局声明
- 为未提供类型的 SDK 写声明
- 类型声明发布和维护

### 7.4 扩展阅读

- [TypeScript Handbook - Async/Await](https://www.typescriptlang.org/docs/handbook/2/iterators-and-generators.html#async-iterables-and-async-generators)
- [MDN - Async/Await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
- [TypeScript Generics Cheatsheet](https://github.com/typescript-cheatsheets/react)