# L5 - 面向对象与装饰器

## 本课时目标
- 掌握 TypeScript 中类的高级特性
- 理解抽象类和接口的关系
- 学习装饰器的概念和使用
- 实现一个类型安全的请求层服务

## 1. 类成员修饰符

### 1.1 访问修饰符

```typescript
class BankAccount {
  // public - 默认，公开访问
  public accountNumber: string;
  
  // private - 私有，仅类内部访问
  private balance: number;
  
  // protected - 受保护，类和子类可访问
  protected owner: string;
  
  // readonly - 只读，初始化后不可修改
  readonly createdAt: Date;
  
  constructor(accountNumber: string, owner: string, initialBalance: number) {
    this.accountNumber = accountNumber;
    this.balance = initialBalance;
    this.owner = owner;
    this.createdAt = new Date();
  }
  
  // public 方法
  public deposit(amount: number): void {
    if (amount > 0) {
      this.balance += amount;
    }
  }
  
  // private 方法
  private validateAmount(amount: number): boolean {
    return amount > 0;
  }
  
  // protected 方法
  protected calculateInterest(): number {
    return this.balance * 0.05; // 5% 利率
  }
  
  // getter 方法
  get currentBalance(): number {
    return this.balance;
  }
}

// 继承示例
class SavingsAccount extends BankAccount {
  private interestRate: number;
  
  constructor(accountNumber: string, owner: string, balance: number, rate: number) {
    super(accountNumber, owner, balance);
    this.interestRate = rate;
  }
  
  public applyInterest(): void {
    const interest = this.calculateInterest(); // 可以访问 protected 方法
    this.deposit(interest * this.interestRate);
  }
}

// 使用
const account = new BankAccount('12345', 'Alice', 1000);
console.log(account.accountNumber); // ✅ 可访问
// console.log(account.balance); // ❌ private，不可访问

const savings = new SavingsAccount('67890', 'Bob', 5000, 1.2);
savings.applyInterest(); // ✅ 可访问
// savings.calculateInterest(); // ❌ protected，不可访问
```

### 1.2 参数属性

```typescript
// 传统写法
class User {
  public name: string;
  private age: number;
  readonly id: string;
  
  constructor(name: string, age: number, id: string) {
    this.name = name;
    this.age = age;
    this.id = id;
  }
}

// 参数属性写法 - 更简洁
class Product {
  constructor(
    public id: string,
    public name: string,
    private price: number,
    readonly createdAt: Date = new Date()
  ) {}
  
  public getPrice(): number {
    return this.price;
  }
}

const product = new Product('p1', 'Laptop', 999);
console.log(product.name); // ✅ public
// console.log(product.price); // ❌ private
console.log(product.createdAt); // ✅ readonly
```

### 1.3 静态成员

```typescript
class MathUtils {
  // 静态属性
  static readonly PI = 3.14159265359;
  private static counter = 0;
  
  // 静态方法
  static circleArea(radius: number): number {
    return this.PI * radius * radius;
  }
  
  static generateId(): string {
    return `id_${++this.counter}_${Date.now()}`;
  }
  
  // 实例方法
  instanceMethod(): void {
    console.log('Instance method');
  }
}

// 使用静态成员
console.log(MathUtils.PI); // 3.14159265359
console.log(MathUtils.circleArea(5)); // 78.53981633975
console.log(MathUtils.generateId()); // id_1_1234567890123

// 实例化后无法访问静态成员
const utils = new MathUtils();
utils.instanceMethod(); // ✅
// utils.PI; // ❌ 实例无法访问静态属性
```

## 2. 抽象类与接口

### 2.1 抽象类

```typescript
// 抽象类不能直接实例化
abstract class Animal {
  // 具体属性
  protected name: string;
  protected age: number;
  
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  
  // 具体方法
  public getInfo(): string {
    return `${this.name} is ${this.age} years old`;
  }
  
  // 抽象方法 - 子类必须实现
  public abstract makeSound(): void;
  
  // 抽象属性 - 子类必须实现
  public abstract readonly species: string;
}

// 继承抽象类
class Dog extends Animal {
  public readonly species = 'Canis lupus';
  
  constructor(name: string, age: number, public breed: string) {
    super(name, age);
  }
  
  public makeSound(): void {
    console.log('Woof! Woof!');
  }
  
  public wagTail(): void {
    console.log(`${this.name} is wagging tail`);
  }
}

class Cat extends Animal {
  public readonly species = 'Felis catus';
  
  constructor(name: string, age: number, public color: string) {
    super(name, age);
  }
  
  public makeSound(): void {
    console.log('Meow!');
  }
  
  public purr(): void {
    console.log(`${this.name} is purring`);
  }
}

// 使用
const dog = new Dog('Buddy', 3, 'Golden Retriever');
console.log(dog.getInfo()); // Buddy is 3 years old
dog.makeSound(); // Woof! Woof!

const cat = new Cat('Whiskers', 2, 'orange');
cat.makeSound(); // Meow!

// const animal = new Animal('Unknown', 0); // ❌ 无法实例化抽象类
```

### 2.2 接口实现

```typescript
// 定义接口
interface Flyable {
  fly(): void;
  altitude: number;
}

interface Swimmable {
  swim(): void;
  dive(depth: number): void;
}

interface Vehicle {
  brand: string;
  model: string;
  start(): void;
  stop(): void;
}

// 实现多个接口
class Airplane implements Vehicle, Flyable {
  constructor(
    public brand: string,
    public model: string,
    public altitude: number = 0
  ) {}
  
  public start(): void {
    console.log(`${this.brand} ${this.model} engine started`);
  }
  
  public stop(): void {
    console.log(`${this.brand} ${this.model} engine stopped`);
  }
  
  public fly(): void {
    this.altitude = 10000;
    console.log(`Flying at ${this.altitude} feet`);
  }
}

// 抽象类实现接口
abstract class Bird implements Flyable {
  public altitude: number = 0;
  
  abstract fly(): void;
  
  public land(): void {
    this.altitude = 0;
    console.log('Landed');
  }
}

class Eagle extends Bird implements Flyable {
  public altitude: number = 0;
  
  public fly(): void {
    this.altitude = 15000;
    console.log(`Eagle soaring at ${this.altitude} feet`);
  }
}
```

### 2.3 接口与抽象类的选择

```typescript
// ✅ 使用接口的场景
// 1. 定义契约，多个不相关的类都可以实现
interface Serializable {
  serialize(): string;
  deserialize(data: string): void;
}

interface Loggable {
  log(message: string): void;
}

// 2. 定义对象结构
interface User {
  id: string;
  name: string;
  email: string;
}

// ✅ 使用抽象类的场景
// 1. 提供部分实现，子类共享代码
abstract class ApiClient {
  protected baseUrl: string;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  protected async request<T>(endpoint: string, options: RequestInit): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, options);
    return response.json();
  }
  
  // 子类必须实现的具体方法
  abstract get<T>(endpoint: string): Promise<T>;
  abstract post<T>(endpoint: string, data: any): Promise<T>;
}

class HttpClient extends ApiClient {
  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' });
  }
  
  async post<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }
}
```

## 3. 装饰器

### 3.1 装饰器基础

```typescript
// 装饰器工厂
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function(...args: any[]) {
    console.log(`Calling ${propertyKey} with args:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`${propertyKey} returned:`, result);
    return result;
  };
  
  return descriptor;
}

// 类装饰器
function entity(tableName: string) {
  return function<T extends { new(...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
      tableName = tableName;
    };
  };
}

// 属性装饰器
function required(target: any, propertyKey: string) {
  const symbol = Symbol(`required_${propertyKey}`);
  
  Object.defineProperty(target, propertyKey, {
    get() {
      return this[symbol];
    },
    set(value: any) {
      if (value === null || value === undefined) {
        throw new Error(`${propertyKey} is required`);
      }
      this[symbol] = value;
    }
  });
}

// 参数装饰器
function validate(type: 'string' | 'number') {
  return (target: any, propertyKey: string, parameterIndex: number) => {
    const existingValidators = Reflect.getMetadata('validators', target, propertyKey) || [];
    existingValidators.push({ type, parameterIndex });
    Reflect.defineMetadata('validators', existingValidators, target, propertyKey);
  };
}
```

### 3.2 实际应用示例

```typescript
// 类装饰器示例
@testable
class Calculator {
  @log
  add(a: number, b: number): number {
    return a + b;
  }
  
  @log
  @deprecated('Use multiply instead')
  oldMultiply(a: number, b: number): number {
    return a * b;
  }
  
  multiply(
    @validate('number') a: number,
    @validate('number') b: number
  ): number {
    return a * b;
  }
}

function testable<T extends { new(...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    tested = true;
  };
}

function deprecated(reason: string) {
  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args: any[]) {
      console.warn(`${propertyKey} is deprecated: ${reason}`);
      return originalMethod.apply(this, args);
    };
  };
}

// 使用
const calc = new Calculator();
calc.add(2, 3); // 会输出日志
calc.oldMultiply(2, 3); // 会输出弃用警告
```

## 4. 实战：请求层服务

### 4.1 需求分析

创建一个类型安全的 HTTP 请求服务，支持：
- 请求/响应类型定义
- 错误处理和重试机制
- 请求拦截器和响应拦截器
- 缓存功能

### 4.2 基础接口定义

```typescript
// HTTP 方法类型
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

// 请求配置
interface RequestConfig {
  url: string;
  method: HttpMethod;
  headers?: Record<string, string>;
  params?: Record<string, any>;
  data?: any;
  timeout?: number;
  retries?: number;
  cache?: boolean;
  cacheTTL?: number;
}

// 响应接口
interface ApiResponse<T = any> {
  data: T;
  status: number;
  statusText: string;
  headers: Record<string, string>;
  config: RequestConfig;
}

// 错误响应
interface ApiError {
  message: string;
  code?: string;
  details?: any;
  timestamp: number;
}

// 拦截器类型
type RequestInterceptor = (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;
type ResponseInterceptor<T = any> = (response: ApiResponse<T>) => ApiResponse<T> | Promise<ApiResponse<T>>;
type ErrorInterceptor = (error: ApiError) => ApiError | Promise<ApiError>;
```

### 4.3 缓存实现

```typescript
// 缓存项
interface CacheItem<T> {
  data: T;
  timestamp: number;
  ttl: number;
  key: string;
}

// 缓存管理器
class CacheManager {
  private cache = new Map<string, CacheItem<any>>();
  
  // 生成缓存键
  private generateKey(config: RequestConfig): string {
    const keyData = {
      url: config.url,
      method: config.method,
      params: config.params,
      data: config.data
    };
    return btoa(JSON.stringify(keyData));
  }
  
  // 设置缓存
  set<T>(config: RequestConfig, data: T, ttl: number = 300000): void { // 默认5分钟
    if (!config.cache) return;
    
    const key = this.generateKey(config);
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
      key
    });
  }
  
  // 获取缓存
  get<T>(config: RequestConfig): T | null {
    if (!config.cache) return null;
    
    const key = this.generateKey(config);
    const item = this.cache.get(key);
    
    if (!item) return null;
    
    // 检查是否过期
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  // 清除缓存
  clear(): void {
    this.cache.clear();
  }
  
  // 清除过期缓存
  clearExpired(): void {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key);
      }
    }
  }
}
```

### 4.4 请求服务类

```typescript
@singleton
class HttpService {
  private baseURL: string;
  private defaultHeaders: Record<string, string>;
  private cacheManager = new CacheManager();
  private requestInterceptors: RequestInterceptor[] = [];
  private responseInterceptors: ResponseInterceptor[] = [];
  private errorInterceptors: ErrorInterceptor[] = [];
  
  constructor(
    baseURL: string = '',
    defaultHeaders: Record<string, string> = {}
  ) {
    this.baseURL = baseURL;
    this.defaultHeaders = defaultHeaders;
    
    // 定期清理过期缓存
    setInterval(() => {
      this.cacheManager.clearExpired();
    }, 60000); // 每分钟清理一次
  }
  
  // 添加拦截器
  public addRequestInterceptor(interceptor: RequestInterceptor): void {
    this.requestInterceptors.push(interceptor);
  }
  
  public addResponseInterceptor<T>(interceptor: ResponseInterceptor<T>): void {
    this.responseInterceptors.push(interceptor);
  }
  
  public addErrorInterceptor(interceptor: ErrorInterceptor): void {
    this.errorInterceptors.push(interceptor);
  }
  
  // 主要请求方法
  public async request<T>(config: RequestConfig): Promise<ApiResponse<T>> {
    // 检查缓存
    const cachedData = this.cacheManager.get<T>(config);
    if (cachedData) {
      return {
        data: cachedData,
        status: 200,
        statusText: 'OK',
        headers: {},
        config
      };
    }
    
    // 应用请求拦截器
    let finalConfig = { ...config };
    for (const interceptor of this.requestInterceptors) {
      finalConfig = await interceptor(finalConfig);
    }
    
    try {
      // 执行请求（带重试机制）
      const response = await this.executeWithRetry<T>(finalConfig);
      
      // 应用响应拦截器
      let finalResponse = response;
      for (const interceptor of this.responseInterceptors) {
        finalResponse = await interceptor(finalResponse);
      }
      
      // 缓存响应
      if (finalConfig.cache && finalResponse.status === 200) {
        this.cacheManager.set(finalConfig, finalResponse.data, finalConfig.cacheTTL);
      }
      
      return finalResponse;
    } catch (error) {
      // 应用错误拦截器
      let apiError: ApiError = {
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: Date.now()
      };
      
      for (const interceptor of this.errorInterceptors) {
        apiError = await interceptor(apiError);
      }
      
      throw apiError;
    }
  }
  
  // 重试机制
  private async executeWithRetry<T>(
    config: RequestConfig,
    attempt: number = 1
  ): Promise<ApiResponse<T>> {
    try {
      return await this.executeRequest<T>(config);
    } catch (error) {
      const maxRetries = config.retries || 3;
      if (attempt < maxRetries && this.shouldRetry(error)) {
        // 指数退避
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        
        return this.executeWithRetry<T>(config, attempt + 1);
      }
      throw error;
    }
  }
  
  // 执行实际请求
  private async executeRequest<T>(config: RequestConfig): Promise<ApiResponse<T>> {
    const { url, method, headers = {}, params, data, timeout = 10000 } = config;
    
    // 构建完整 URL
    let fullUrl = `${this.baseURL}${url}`;
    if (params) {
      const searchParams = new URLSearchParams();
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          searchParams.append(key, String(value));
        }
      });
      fullUrl += `?${searchParams.toString()}`;
    }
    
    // 准备请求头
    const requestHeaders = {
      ...this.defaultHeaders,
      ...headers
    };
    
    // 准备请求选项
    const fetchOptions: RequestInit = {
      method,
      headers: requestHeaders
    };
    
    if (data && method !== 'GET') {
      fetchOptions.body = typeof data === 'string' ? data : JSON.stringify(data);
    }
    
    // 创建带超时的请求
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    fetchOptions.signal = controller.signal;
    
    try {
      const response = await fetch(fullUrl, fetchOptions);
      clearTimeout(timeoutId);
      
      // 解析响应头
      const responseHeaders: Record<string, string> = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });
      
      // 解析响应数据
      const responseData = await this.parseResponse<T>(response);
      
      return {
        data: responseData,
        status: response.status,
        statusText: response.statusText,
        headers: responseHeaders,
        config
      };
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }
  
  // 解析响应
  private async parseResponse<T>(response: Response): Promise<T> {
    const contentType = response.headers.get('content-type');
    
    if (contentType?.includes('application/json')) {
      return response.json();
    }
    
    if (contentType?.includes('text/')) {
      return response.text() as unknown as T;
    }
    
    return response.arrayBuffer() as unknown as T;
  }
  
  // 判断是否应该重试
  private shouldRetry(error: any): boolean {
    if (error.name === 'AbortError') return false;
    if (error.status >= 400 && error.status < 500) return false; // 客户端错误不重试
    if (error.status >= 500) return true; // 服务器错误重试
    if (error.name === 'TypeError') return true; // 网络错误重试
    return false;
  }
  
  // 便捷方法
  public get<T>(url: string, config: Partial<RequestConfig> = {}): Promise<ApiResponse<T>> {
    return this.request<T>({ url, method: 'GET', ...config });
  }
  
  public post<T>(url: string, data: any, config: Partial<RequestConfig> = {}): Promise<ApiResponse<T>> {
    return this.request<T>({ url, method: 'POST', data, ...config });
  }
  
  public put<T>(url: string, data: any, config: Partial<RequestConfig> = {}): Promise<ApiResponse<T>> {
    return this.request<T>({ url, method: 'PUT', data, ...config });
  }
  
  public delete<T>(url: string, config: Partial<RequestConfig> = {}): Promise<ApiResponse<T>> {
    return this.request<T>({ url, method: 'DELETE', ...config });
  }
}

// 单例装饰器
function singleton<T extends { new(...args: any[]): {} }>(constructor: T) {
  let instance: T | null = null;
  
  return new class extends constructor {
    constructor(...args: any[]) {
      if (instance) return instance;
      instance = super(...args);
      return instance;
    }
  } as T;
}
```

### 4.5 使用示例

```typescript
// 定义 API 类型
interface User {
  id: string;
  name: string;
  email: string;
}

interface CreateUserRequest {
  name: string;
  email: string;
  password: string;
}

// 初始化服务
const httpService = new HttpService('https://api.example.com', {
  'Content-Type': 'application/json',
  'Authorization': 'Bearer your-token-here'
});

// 添加拦截器
httpService.addRequestInterceptor(config => {
  console.log('Request:', config);
  return config;
});

httpService.addResponseInterceptor(response => {
  console.log('Response:', response);
  return response;
});

httpService.addErrorInterceptor(error => {
  console.error('Error:', error);
  return error;
});

// 使用服务
async function example() {
  try {
    // 获取用户列表（带缓存）
    const usersResponse = await httpService.get<User[]>('/users', {
      cache: true,
      cacheTTL: 600000 // 10分钟
    });
    
    console.log('Users:', usersResponse.data);
    
    // 创建用户
    const newUser: CreateUserRequest = {
      name: 'John Doe',
      email: 'john@example.com',
      password: 'password123'
    };
    
    const createResponse = await httpService.post<User>('/users', newUser);
    console.log('Created user:', createResponse.data);
    
  } catch (error) {
    console.error('API Error:', error);
  }
}

example();
```

## 5. 练习与作业

### 5.1 基础练习

1. **访问修饰符练习**
   ```typescript
   // 设计一个 BankAccount 类，包含：
   // - private balance
   // - protected accountNumber  
   // - public 方法
   // - 实现 SavingsAccount 子类
   ```

2. **抽象类练习**
   ```typescript
   // 设计一个 PaymentProcessor 抽象类
   // 包含抽象方法 processPayment()
   // 实现 CreditCardProcessor 和 PayPalProcessor
   ```

### 5.2 进阶练习

3. **装饰器实现**
   ```typescript
   // 实现以下装饰器：
   // 1. @cache - 方法结果缓存
   // 2. @measure - 方法执行时间测量
   // 3. @validate - 参数验证装饰器
   ```

### 5.3 实战作业

4. **完整的 API 客户端**
   - 扩展 HttpService 支持文件上传
   - 实现 WebSocket 客户端类
   - 添加请求队列和节流功能
   - 实现类型安全的 GraphQL 客户端

## 6. 最佳实践

### 6.1 类设计原则

```typescript
// ✅ 单一职责原则
class UserRepository {
  async findById(id: string): Promise<User> { /* ... */ }
  async save(user: User): Promise<void> { /* ... */ }
}

class UserService {
  constructor(private repo: UserRepository) {}
  async getUser(id: string): Promise<User> { /* ... */ }
  async updateUser(user: User): Promise<void> { /* ... */ }
}

// ✅ 依赖倒置原则
interface PaymentGateway {
  process(amount: number): Promise<boolean>;
}

class OrderService {
  constructor(private paymentGateway: PaymentGateway) {}
}

// ✅ 接口隔离原则
interface Reader {
  read(): string;
}

interface Writer {
  write(data: string): void;
}

// 而不是巨大的 FileSystem 接口
```

### 6.2 装饰器使用原则

```typescript
// ✅ 装饰器用于横切关注点
@entity('users')
@cacheable()
class UserService {
  @log()
  @validate()
  async createUser(@required() data: UserData): Promise<User> { /* ... */ }
}

// ✅ 保持装饰器的纯粹性
function entity(tableName: string) {
  return function(constructor: Function) {
    // 只做元数据标记，不改变类行为
    Reflect.defineMetadata('tableName', tableName, constructor);
  };
}

// ❌ 避免在装饰器中做复杂逻辑
// function badDecorator(target: any) {
//   // 复杂的业务逻辑不应该放在装饰器中
//   const config = loadConfig();
//   connectToDatabase(config);
//   // ...
// }
```

## 7. 课程总结

### 7.1 核心知识点回顾

1. **类成员修饰符**：public、private、protected、readonly 的使用
2. **抽象类与接口**：理解两者区别和适用场景
3. **装饰器**：学习装饰器的概念和实际应用
4. **请求层服务**：实现完整的 HTTP 客户端架构

### 7.2 关键概念

- **封装**：通过访问修饰符实现数据隐藏
- **继承**：代码复用和多态的基础
- **多态**：通过接口和抽象类实现
- **横切关注点**：装饰器解决的主要问题

### 7.3 下节预告

下一课时将学习泛型基础，包括：
- 泛型函数、类和接口
- 泛型约束和默认值
- 条件类型的基础应用
- 实现仓储工具库接口设计

### 7.4 扩展阅读

- [TypeScript Handbook - Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
- [TypeScript Handbook - Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)