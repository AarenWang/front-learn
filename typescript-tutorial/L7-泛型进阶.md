# L7 - 泛型进阶

## 本课时目标
- 深入理解条件类型的工作原理
- 掌握映射类型的高级应用
- 学会使用 infer 关键字进行类型推断
- 实现一个灵活的 API 响应类型提取工具

## 1. 条件类型深入

### 1.1 分布式条件类型

```typescript
// 基础条件类型
type IsString<T> = T extends string ? true : false;

type Test1 = IsString<string>;   // true
type Test2 = IsString<number>;   // false

// 分布式条件类型 - 对联合类型进行分发
type ToString<T> = T extends string | number ? `${T}` : never;

type Test3 = ToString<string | number>; // `${string}` | `${number}`
type Test4 = ToString<boolean>;         // never

// 分布式特性示例
type NonNullable<T> = T extends null | undefined ? never : T;

type Test5 = NonNullable<string | null | undefined>; // string
type Test6 = NonNullable<number | null>;              // number

// 自定义分布式类型
type Arrayify<T> = T extends any ? T[] : never;

type Test7 = Arrayify<string | number>; // string[] | number[]
```

### 1.2 条件类型的嵌套

```typescript
// 复杂的条件类型嵌套
type DeepReadonly<T> = T extends object
  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
  : T;

type ComplexObject = {
  user: {
    name: string;
    address: {
      street: string;
      city: string;
    };
  };
  tags: string[];
};

type ReadonlyObject = DeepReadonly<ComplexObject>;
// 所有嵌套属性都变为只读

// 条件类型与映射类型结合
type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];

type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];

interface Example {
  required: string;
  optional?: number;
}

type Optional = OptionalKeys<Example>;    // "optional"
type Required = RequiredKeys<Example>;   // "required"
```

### 1.3 条件类型的实际应用

```typescript
// 函数参数类型提取
type FirstParameter<T> = T extends (first: infer U, ...args: any[]) => any
  ? U
  : never;

type Func1 = (name: string, age: number) => void;
type FirstParam1 = FirstParameter<Func1>; // string

// 返回值类型提取
type ReturnType<T> = T extends (...args: any[]) => infer R
  ? R
  : never;

type Func2 = () => Promise<User>;
type Return2 = ReturnType<Func2>; // Promise<User>

// Promise 包装类型提取
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

type AsyncUser = Promise<User>;
type SyncUser = UnwrapPromise<AsyncUser>; // User
```

## 2. 映射类型高级应用

### 2.1 动态键类型

```typescript
// 基础映射类型
type Stringify<T> = {
  [K in keyof T]: string;
};

// 条件映射类型
type StringifyNonFunctions<T> = {
  [K in keyof T]: T[K] extends Function ? T[K] : string;
};

// 映射类型与条件类型结合
type PartialByKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

interface User {
  id: string;
  name: string;
  email: string;
  age: number;
}

type UserWithoutRequiredId = PartialByKeys<User, 'id'>;
// { id?: string; name: string; email: string; age: number; }

// 动态键名映射
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type UserGetters = Getters<User>;
// {
//   getId: () => string;
//   getName: () => string;
//   getEmail: () => string;
//   getAge: () => number;
// }
```

### 2.2 键重映射

```typescript
// 键重映射语法 (as)
type SnakeCase<T> = T extends `${infer First}${infer Rest}`
  ? `${First extends Uppercase<First> ? `_${Lowercase<First>}` : First}${SnakeCase<Rest>}`
  : T;

type SnakeCaseKeys<T> = {
  [K in keyof T as SnakeCase<string & K>]: T[K];
};

interface ApiUser {
  firstName: string;
  lastName: string;
  emailAddress: string;
}

type SnakeCaseUser = SnakeCaseKeys<ApiUser>;
// {
//   first_name: string;
//   last_name: string;
//   email_address: string;
// }

// 过滤键的映射类型
type StringKeys<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K];
};

type UserStringFields = StringKeys<User>;
// { name: string; email: string; }

// 递归键重映射
type DeepReadonly<T> = T extends object
  ? {
      readonly [K in keyof T]: DeepReadonly<T[K]>;
    }
  : T;

type DeepPartial<T> = T extends object
  ? {
      [K in keyof T]?: DeepPartial<T[K]>;
    }
  : T;
```

### 2.3 实用工具类型

```typescript
// 深度可选
type DeepOptional<T> = {
  [K in keyof T]?: T[K] extends object ? DeepOptional<T[K]> : T[K];
};

// 深度必选
type DeepRequired<T> = {
  [K in keyof T]-?: T[K] extends object ? DeepRequired<T[K]> : T[K];
};

// 选择性可选
type SelectivePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// 选择性必选
type SelectiveRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

// 条件属性类型
type ConditionalProps<T, Condition extends boolean> = Condition extends true
  ? Partial<T>
  : T;

// 使用示例
interface Product {
  id: string;
  name: string;
  price: number;
  metadata: {
    category: string;
    tags: string[];
    dimensions: {
      width: number;
      height: number;
      depth: number;
    };
  };
}

type PartialProduct = DeepOptional<Product>;
type RequiredProduct = DeepRequired<PartialProduct>;
type PartialMetadata = SelectivePartial<Product, 'metadata'>;
```

## 3. infer 关键字深入

### 3.1 infer 基础用法

```typescript
// 从函数类型推断参数
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

type Func = (a: string, b: number, c: boolean) => void;
type FuncParams = Parameters<Func>; // [string, number, boolean]

// 从构造函数推断实例类型
type InstanceType<T> = T extends abstract new (...args: any[]) => infer R
  ? R
  : never;

class User {
  constructor(public name: string) {}
}

type UserInstance = InstanceType<typeof User>; // User

// 从数组类型推断元素类型
type ArrayElement<T> = T extends (infer U)[] ? U : never;

type StringArray = string[];
type StringElement = ArrayElement<StringArray>; // string

// 从 Promise 类型推断解析类型
type PromiseType<T> = T extends Promise<infer U> ? U : T;

type AsyncData = Promise<{ id: string; name: string }>;
type DataType = PromiseType<AsyncData>; // { id: string; name: string }
```

### 3.2 复杂 infer 模式

```typescript
// 解析函数返回的 Promise 类型
type AsyncReturnType<T> = T extends (...args: any[]) => Promise<infer R>
  ? R
  : T extends (...args: any[]) => infer R
  ? R
  : never;

type AsyncFunc = () => Promise<string>;
type SyncFunc = () => number;

type AsyncResult = AsyncReturnType<AsyncFunc>; // string
type SyncResult = AsyncReturnType<SyncFunc>;  // number

// 解析对象中的方法返回类型
type MethodReturnTypes<T> = {
  [K in keyof T]: T[K] extends (...args: any[]) => infer R ? R : never;
};

class ApiClient {
  getUser() { return Promise.resolve({ id: '1', name: 'Alice' }); }
  getPosts() { return Promise.resolve([{ id: '1' }]); }
  ping() { return 'pong'; }
}

type ApiReturns = MethodReturnTypes<ApiClient>;
// {
//   getUser: Promise<{ id: string; name: string }>;
//   getPosts: Promise<{ id: string; }[]>;
//   ping: string;
// }

// 解析函数元组
type Flatten<T> = T extends Array<infer U> ? U : T;

type NestedArray = Array<Array<string>>;
type Flattened = Flatten<NestedArray>; // Array<string>

// 解析函数重载
type OverloadReturnType<T> = T extends { (...args: any[]): any; (...args: any[]): infer R }
  ? R
  : never;

function processData(data: string): string;
function processData(data: number): number;
function processData(data: string | number): string | number {
  return data;
}

type ProcessReturnType = OverloadReturnType<typeof processData>; // string | number
```

### 3.3 infer 与字符串模板

```typescript
// 解析模板字符串
type ParseTemplate<T> = T extends `${infer Start}{{infer Param}}${infer End}`
  ? [Start, Param, ...ParseTemplate<End>]
  : [T];

type Template = "Hello {{name}}, welcome to {{place}}!";
type Parsed = ParseTemplate<Template>;
// ["Hello ", "name", ", welcome to ", "place", "!"]

// 解析路径参数
type RouteParams<T> = T extends `${string}:${infer Param}/${infer Rest}`
  ? Param | RouteParams<`/${Rest}`>
  : T extends `${string}:${infer Param}`
  ? Param
  : never;

type UserRoute = "/users/:id/posts/:postId";
type Params = RouteParams<UserRoute>; // "id" | "postId"

// 解析 CSS 属性
type CSSValue<T> = T extends `${infer Number}px`
  ? { type: 'pixel'; value: Number }
  : T extends `${infer Number}%`
  ? { type: 'percentage'; value: Number }
  : { type: 'string'; value: T };

type Width = CSSValue<'100px'>; // { type: 'pixel'; value: '100' }
type Height = CSSValue<'50%'>; // { type: 'percentage'; value: '50' }
```

## 4. 实战：API 响应类型提取工具

### 4.1 需求分析

创建一个强大的 API 类型工具，支持：
- 从 API 响应自动提取类型
- 支持嵌套对象和数组
- 错误类型处理
- 查询参数类型推断

### 4.2 基础类型定义

```typescript
// HTTP 状态码类型
type StatusCode = 200 | 201 | 400 | 401 | 403 | 404 | 500;

// API 响应基础结构
interface ApiStructure<T = any, E = any> {
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: E;
  };
  meta?: {
    total?: number;
    page?: number;
    limit?: number;
    timestamp: number;
  };
  status: StatusCode;
}

// 分页响应类型
interface PaginatedResponse<T> extends ApiStructure<T[]> {
  meta: Required<ApiStructure['meta']> & {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

// 错误详情类型
interface ErrorDetails {
  field?: string;
  code?: string;
  message?: string;
  value?: any;
}

// 通用错误类型
type ApiError = ApiStructure<never, ErrorDetails | ErrorDetails[]>;
```

### 4.3 响应类型提取器

```typescript
// 提取成功响应数据类型
type ExtractData<T> = T extends ApiStructure<infer D, any> ? D : never;

// 提取错误类型
type ExtractError<T> = T extends ApiStructure<any, infer E> ? E : never;

// 提取分页数据类型
type ExtractPaginatedData<T> = T extends PaginatedResponse<infer D> ? D : never;

// 判断是否为分页响应
type IsPaginated<T> = T extends PaginatedResponse<any> ? true : false;

// 提取字段类型（支持嵌套路径）
type ExtractFieldType<T, Path extends string> = Path extends keyof T
  ? T[Path]
  : Path extends `${infer First}.${infer Rest}`
  ? First extends keyof T
    ? ExtractFieldType<T[First], Rest>
    : never
  : never;

// 类型守卫函数
function isSuccess<T>(response: ApiStructure<T>): response is ApiStructure<T, never> & { data: T } {
  return response.status >= 200 && response.status < 300 && response.data !== undefined;
}

function isError<T>(response: ApiStructure<T>): response is ApiError {
  return response.status >= 400 || response.error !== undefined;
}

function isPaginated<T>(response: ApiStructure<T>): response is PaginatedResponse<T> {
  return response.meta !== undefined && 'total' in response.meta && 'page' in response.meta;
}
```

### 4.4 高级类型提取

```typescript
// 从函数调用中提取类型
type ExtractApiCallReturn<T> = T extends (...args: any[]) => Promise<infer R>
  ? R extends ApiStructure<infer D, any>
    ? D
    : R
  : never;

// 从 Axios 响应中提取类型（模拟）
type AxiosResponse<T = any> = {
  data: T;
  status: number;
  statusText: string;
  headers: Record<string, string>;
};

type ExtractAxiosData<T> = T extends Promise<AxiosResponse<infer D>> ? D : never;

// 数组元素类型提取
type ArrayElement<T> = T extends (infer U)[] ? U : never;

// 深度提取嵌套对象的字段类型
type DeepExtract<T, Path extends string> = Path extends keyof T
  ? T[Path]
  : Path extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? T[K] extends object
      ? DeepExtract<T[K], Rest>
      : never
    : never
  : never;

// 递归提取所有可能的字段路径
type AllPaths<T, Prefix extends string = ''> = T extends object
  ? {
      [K in keyof T]: T[K] extends object
        ? AllPaths<T[K], `${Prefix}${K & string}.`>
        : `${Prefix}${K & string}`;
    }[keyof T]
  : never;
```

### 4.5 API 客户端类型生成器

```typescript
// API 方法定义
interface ApiMethod<TParams, TResponse, TQuery = {}> {
  url: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  params?: TParams;
  query?: TQuery;
  response: TResponse;
}

// 生成类型安全的 API 调用函数
type ApiCallFunction<T extends ApiMethod<any, any, any>> = (
  params?: T['params'],
  query?: T['query']
) => Promise<T['response']>;

// 从路由模板生成参数类型
type RouteParams<T extends string> = T extends `${string}:${infer Param}/${infer Rest}`
  ? { [K in Param]: string } & RouteParams<`/${Rest}`>
  : T extends `${string}:${infer Param}`
  ? { [K in Param]: string }
  : {};

// 生成完整的 API 类型
type GenerateApi<T extends Record<string, ApiMethod<any, any, any>>> = {
  [K in keyof T]: T[K] extends { url: infer U; method: infer M }
    ? U extends string
      ? RouteParams<U> extends never
        ? ApiCallFunction<T[K]>
        : (params: RouteParams<U>) => ApiCallFunction<T[K]>
      : never
    : never;
};

// 实际使用示例
interface UserEndpoints {
  getUser: ApiMethod<
    { id: string },
    ApiStructure<{ id: string; name: string; email: string }>
  > & { url: '/users/:id'; method: 'GET' };
  
  getUsers: ApiMethod<
    never,
    PaginatedResponse<{ id: string; name: string; email: string }>,
    { page?: number; limit?: number; search?: string }
  > & { url: '/users'; method: 'GET' };
  
  createUser: ApiMethod<
    { name: string; email: string; password: string },
    ApiStructure<{ id: string; name: string; email: string }>
  > & { url: '/users'; method: 'POST' };
}

type UserApi = GenerateApi<UserEndpoints>;
```

### 4.6 类型安全的响应处理器

```typescript
// 响应处理器基础接口
interface ResponseHandler<T> {
  onSuccess(data: ExtractData<T>): void;
  onError(error: ExtractError<T>): void;
  onLoading?(): void;
  onComplete?(): void;
}

// 类型安全的响应处理函数
function handleApiResponse<T>(
  response: ApiStructure<T>,
  handler: ResponseHandler<T>
): void {
  if (isSuccess(response)) {
    handler.onSuccess(response.data);
  } else if (isError(response)) {
    handler.onError(response.error!);
  }
  
  handler.onComplete?.();
}

// 高级处理器 - 支持分页
interface PaginatedResponseHandler<T> extends ResponseHandler<T[]> {
  onPaginated?(data: ExtractPaginatedData<T>, meta: Required<ApiStructure['meta']>): void;
}

function handlePaginatedResponse<T>(
  response: ApiStructure<T[]>,
  handler: PaginatedResponseHandler<T>
): void {
  if (isSuccess(response)) {
    if (isPaginated(response)) {
      handler.onPaginated?.(response.data, response.meta);
    } else {
      handler.onSuccess(response.data);
    }
  } else if (isError(response)) {
    handler.onError(response.error!);
  }
  
  handler.onComplete?.();
}

// 使用示例
async function fetchUser(id: string) {
  const response = await apiClient.get(`/users/${id}`);
  
  handleApiResponse(response, {
    onSuccess: (user) => {
      // user 类型自动推断为 { id: string; name: string; email: string }
      console.log(`User ${user.name} fetched successfully`);
    },
    onError: (error) => {
      // error 类型自动推断为 ErrorDetails
      console.error('Failed to fetch user:', error.message);
    },
    onLoading: () => console.log('Loading user...')
  });
}

async function fetchUsers(page = 1) {
  const response = await apiClient.get('/users', { page });
  
  handlePaginatedResponse(response, {
    onPaginated: (users, meta) => {
      // users 和 meta 类型自动推断
      console.log(`Page ${meta.page} of ${meta.totalPages}, ${users.length} users`);
    },
    onError: (error) => {
      console.error('Failed to fetch users:', error);
    }
  });
}
```

### 4.7 类型验证工具

```typescript
// 运行时类型验证生成器
function createValidator<T>(schema: ValidationSchema<T>): (data: unknown) => data is T {
  return (data: unknown): data is T => {
    return validate(data, schema);
  };
}

// 验证架构类型
type ValidationSchema<T> = {
  [K in keyof T]: T[K] extends string
    ? { type: 'string' | 'email' | 'url'; required?: boolean }
    : T[K] extends number
    ? { type: 'number' | 'integer'; min?: number; max?: number; required?: boolean }
    : T[K] extends boolean
    ? { type: 'boolean'; required?: boolean }
    : T[K] extends any[]
    ? { type: 'array'; items: ValidationSchema<T[K][0]>; required?: boolean }
    : T[K] extends object
    ? { type: 'object'; properties: ValidationSchema<T[K]>; required?: boolean }
    : { type: 'unknown' };
};

// 使用示例
interface User {
  id: string;
  name: string;
  email: string;
  age: number;
  active: boolean;
  roles: string[];
}

const userSchema: ValidationSchema<User> = {
  id: { type: 'string', required: true },
  name: { type: 'string', required: true },
  email: { type: 'email', required: true },
  age: { type: 'integer', min: 0, max: 150, required: true },
  active: { type: 'boolean', required: true },
  roles: { type: 'array', items: { type: 'string' }, required: true }
};

const isUser = createValidator(userSchema);

// API 响应验证
function validateApiResponse<T>(
  response: unknown,
  schema: ValidationSchema<T>
): response is ApiStructure<T> {
  if (typeof response !== 'object' || response === null) {
    return false;
  }
  
  const api = response as ApiStructure<T>;
  
  // 验证状态码
  if (typeof api.status !== 'number') {
    return false;
  }
  
  // 根据状态码验证数据或错误
  if (api.status >= 200 && api.status < 300) {
    return api.data !== undefined && validate(api.data, schema);
  } else {
    return api.error !== undefined;
  }
}

// 使用验证
const rawResponse = await fetch('/api/users/1');
const jsonResponse = await rawResponse.json();

if (validateApiResponse(jsonResponse, userSchema)) {
  // jsonResponse 现在被推断为 ApiStructure<User>
  const user = jsonResponse.data; // User 类型
  console.log(`User ${user.name} validated successfully`);
}
```

## 5. 练习与作业

### 5.1 基础练习

1. **条件类型练习**
   ```typescript
   // 实现：
   // 1. Head<T> - 获取数组的第一个元素类型
   // 2. Tail<T> - 获取数组除第一个元素外的类型
   // 3. Length<T> - 获取数组长度类型
   ```

2. **infer 练习**
   ```typescript
   // 实现：
   // 1. ConstructorParameters<T> - 提取构造函数参数
   // 2. ResolveType<T> - 解析 Promise 或泛型类型
   // 3. FlattenArray<T> - 扁平化多维数组类型
   ```

### 5.2 进阶练习

3. **高级工具类型**
   ```typescript
   // 实现：
   // 1. UnionToIntersection<T> - 联合类型转交叉类型
   // 2. OptionalPropertyOf<T> - 获取可选属性
   // 3. RequiredPropertyOf<T> - 获取必选属性
   ```

### 5.3 实战作业

4. **完整的 API 类型生成器**
   - 从 OpenAPI 规范生成 TypeScript 类型
   - 支持嵌套对象和数组类型
   - 生成查询参数类型
   - 创建类型安全的客户端 SDK
   - 添加运行时类型验证

## 6. 最佳实践

### 6.1 条件类型设计原则

```typescript
// ✅ 保持简单和可读
type IsArray<T> = T extends any[] ? true : false;

// ✅ 使用有意义的状态名称
type RequestStatus<T> = T extends { loading: true } 
  ? 'loading' 
  : T extends { error: any } 
  ? 'error' 
  : 'success';

// ❌ 避免过度嵌套
// type Bad<T> = T extends A 
//   ? T extends B 
//     ? T extends C 
//       ? never 
//       : unknown 
//     : unknown 
//   : unknown;
```

### 6.2 infer 使用原则

```typescript
// ✅ 使用 infer 提取有用信息
type ExtractPromise<T> = T extends Promise<infer U> ? U : T;

// ✅ 在模板字符串中使用 infer
type ExtractRouteParams<T> = T extends `${string}:${infer Param}/${infer Rest}`
  ? Param | ExtractRouteParams<`/${Rest}`>
  : T extends `${string}:${infer Param}`
  ? Param
  : never;

// ❌ 避免在简单场景中使用 infer
// type Bad<T> = T extends infer U ? U : never; // 直接用 T 即可
```

## 7. 课程总结

### 7.1 核心知识点回顾

1. **条件类型**：分布式特性和嵌套应用
2. **映射类型**：动态键名和键重映射
3. **infer 关键字**：类型推断和模式匹配
4. **API 响应工具**：类型安全的响应处理

### 7.2 关键概念

- **类型分发**：条件类型对联合类型的处理
- **模式匹配**：使用 infer 进行类型模式匹配
- **递归类型**：递归定义和解析复杂类型
- **类型守卫**：编译时和运行时类型验证

### 7.3 下节预告

下一课时将学习模块化与声明组织，包括：
- ES 模块系统和模块解析
- 类型声明文件的组织结构
- 命名空间和模块的最佳实践
- 创建可复用的类型包

### 7.4 扩展阅读

- [TypeScript Handbook - Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
- [TypeScript Handbook - Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
- [Advanced TypeScript Types Cheatsheet](https://github.com/type-challenges/type-challenges)