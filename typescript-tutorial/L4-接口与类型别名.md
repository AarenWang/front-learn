# L4 - 接口与类型别名

## 本课时目标
- 理解 interface 和 type 的区别与选择场景
- 掌握交叉类型和联合类型的使用
- 学会使用类型映射和条件类型
- 实现一个完整的用户领域模型

## 1. interface vs type

### 1.1 基本定义方式

```typescript
// interface 定义
interface User {
  id: string;
  name: string;
  email: string;
}

// type 定义
type Product = {
  id: string;
  name: string;
  price: number;
};

// 两者都可以描述对象结构
const user: User = {
  id: '1',
  name: 'Alice',
  email: 'alice@example.com'
};

const product: Product = {
  id: 'p1',
  name: 'Laptop',
  price: 999
};
```

### 1.2 主要区别

#### 声明合并 (Declaration Merging)

```typescript
// ✅ interface 支持声明合并
interface User {
  id: string;
  name: string;
}

interface User {
  email: string;
}

// User 类型自动合并所有属性
const user: User = {
  id: '1',
  name: 'Alice',
  email: 'alice@example.com'
};

// ❌ type 不支持声明合并
// type Product = {
//   id: string;
// };
// type Product = {  // 错误：重复标识符
//   name: string;
// };
```

#### 继承方式

```typescript
// interface 继承
interface Admin extends User {
  role: 'admin';
  permissions: string[];
}

// type 继承（使用交叉类型）
type Manager = Product & {
  manager: string;
  department: string;
};

// 多重继承
interface SuperAdmin extends Admin, User {
  level: 'super';
}

type SuperProduct = Product & Manager & {
  special: boolean;
};
```

#### 复杂类型定义

```typescript
// type 可以定义更复杂的类型
type StringOrNumber = string | number;
type UserFunction = (name: string) => User;
type PartialUser = Partial<User>;
type UserKeys = keyof User;

// ❌ interface 不能定义这些类型
// interface BadType = string | number; // 错误
```

### 1.3 选择指南

```typescript
// ✅ 使用 interface 的场景
// 1. 定义对象结构，需要继承
interface Shape {
  area(): number;
}

interface Circle extends Shape {
  radius: number;
}

// 2. 库的公共 API，需要扩展性
interface Logger {
  log(message: string): void;
}

// ✅ 使用 type 的场景
// 1. 联合类型
type Status = 'pending' | 'success' | 'error';

// 2. 函数类型
type EventHandler<T> = (event: T) => void;

// 3. 复杂的工具类型
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// 4. 元组类型
type Point = [number, number];
type Color = [number, number, number, number];
```

## 2. 交叉类型与联合类型

### 2.1 联合类型 (Union Types)

```typescript
// 基本联合类型
type Status = 'loading' | 'success' | 'error';
type ID = string | number;
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

// 对象联合类型
type LoadingState = {
  status: 'loading';
  message?: string;
};

type SuccessState = {
  status: 'success';
  data: any;
};

type ErrorState = {
  status: 'error';
  error: Error;
};

type AsyncState = LoadingState | SuccessState | ErrorState;

// 使用联合类型
function handleAsyncState(state: AsyncState) {
  switch (state.status) {
    case 'loading':
      console.log('Loading...', state.message);
      break;
    case 'success':
      console.log('Success:', state.data);
      break;
    case 'error':
      console.log('Error:', state.error);
      break;
  }
}
```

### 2.2 交叉类型 (Intersection Types)

```typescript
// 基本交叉类型
type Person = {
  name: string;
  age: number;
};

type Employee = {
  id: string;
  department: string;
};

type EmployeePerson = Person & Employee;

// 交叉类型的结果
const employee: EmployeePerson = {
  name: 'John',
  age: 30,
  id: '123',
  department: 'IT'
};

// 带方法的交叉类型
type Serializable = {
  serialize(): string;
};

type Validatable = {
  validate(): boolean;
};

type Model = Serializable & Validatable & {
  id: string;
  data: any;
};

// 字面量类型的交叉会产生 never
type Impossible = string & number; // never
```

### 2.3 联合类型的收窄

```typescript
// 类型守卫
function processValue(value: string | number) {
  if (typeof value === 'string') {
    // value 在这里是 string
    return value.toUpperCase();
  } else {
    // value 在这里是 number
    return value.toFixed(2);
  }
}

// instanceof 检查
class Cat {
  meow() {}
}

class Dog {
  bark() {}
}

function handleAnimal(animal: Cat | Dog) {
  if (animal instanceof Cat) {
    animal.meow();
  } else {
    animal.bark();
  }
}

// in 操作符
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

function handleAquatic(animal: Bird | Fish) {
  if ('fly' in animal) {
    animal.fly();
  } else {
    animal.swim();
  }
}
```

## 3. 映射类型与条件类型

### 3.1 映射类型基础

```typescript
// 基本映射类型
type Stringify<T> = {
  [K in keyof T]: string;
};

type User = {
  id: number;
  name: string;
  active: boolean;
};

type StringifiedUser = Stringify<User>;
// 结果：{ id: string; name: string; active: string; }

// 添加修饰符
type ReadonlyUser = {
  readonly [K in keyof T]: T[K];
};

type OptionalUser = {
  [K in keyof T]?: T[K];
};

// 移除修饰符
type Mutable<T> = {
  -readonly [K in keyof T]: T[K];
};

type RequiredUser = {
  [K in keyof T]-?: T[K];
};
```

### 3.2 条件类型基础

```typescript
// 基本条件类型
type IsString<T> = T extends string ? true : false;

type Test1 = IsString<string>;  // true
type Test2 = IsString<number>;  // false

// 分布式条件类型
type ToArray<T> = T extends any ? T[] : never;
type StringOrNumberArray = ToArray<string | number>;
// 结果：string[] | number[]

// infer 关键字
type FirstElement<T> = T extends (infer U)[] ? U : never;
type First = FirstElement<string[]>; // string

type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
type AddReturn = ReturnType<(a: number, b: number) => number>; // number
```

### 3.3 内置工具类型

```typescript
// Partial<T> - 所有属性可选
type PartialUser = Partial<User>;

// Required<T> - 所有属性必选
type RequiredUser = Required<PartialUser>;

// Readonly<T> - 所有属性只读
type ReadonlyUser = Readonly<User>;

// Pick<T, K> - 选择特定属性
type UserBasic = Pick<User, 'id' | 'name'>;

// Omit<T, K> - 排除特定属性
type UserWithoutId = Omit<User, 'id'>;

// Record<K, T> - 创建记录类型
type UserRoles = Record<string, 'admin' | 'user' | 'guest'>;

// Extract<T, U> - 提取联合类型中的部分
type Numbers = Extract<string | number, number>;

// Exclude<T, U> - 排除联合类型中的部分
type StringsOnly = Exclude<string | number, number>;
```

## 4. 实战：用户领域模型

### 4.1 需求分析

设计一个完整的用户管理系统，包括：
- 用户基础信息
- 角色权限管理
- 状态机管理
- 类型安全的 API 响应

### 4.2 领域模型设计

```typescript
// 第一步：定义基础类型
type UUID = string;
type Timestamp = number;
type Email = string & { readonly __brand: 'Email' };
type Password = string & { readonly __brand: 'Password' };

// 创建类型安全的构造函数
function createEmail(email: string): Email {
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    throw new Error('Invalid email format');
  }
  return email as Email;
}

function createPassword(password: string): Password {
  if (password.length < 8) {
    throw new Error('Password too short');
  }
  return password as Password;
}

// 第二步：用户状态定义
type UserStatus = 
  | { status: 'invited'; invitedAt: Timestamp }
  | { status: 'registered'; registeredAt: Timestamp }
  | { status: 'active'; activatedAt: Timestamp }
  | { status: 'suspended'; suspendedAt: Timestamp; reason: string }
  | { status: 'deleted'; deletedAt: Timestamp };

// 第三步：角色和权限定义
type Permission = 
  | 'users.read'
  | 'users.write'
  | 'users.delete'
  | 'content.read'
  | 'content.write'
  | 'admin.system';

type Role = {
  id: UUID;
  name: string;
  permissions: Permission[];
  level: number;
};

type UserRole = {
  userId: UUID;
  roleId: UUID;
  assignedAt: Timestamp;
  assignedBy: UUID;
};
```

### 4.3 用户实体定义

```typescript
// 用户基础信息
interface UserProfile {
  id: UUID;
  email: Email;
  username: string;
  firstName: string;
  lastName: string;
  avatar?: string;
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

// 用户完整实体
type User = UserProfile & {
  status: UserStatus;
  roles: UserRole[];
  lastLoginAt?: Timestamp;
  preferences: UserPreferences;
};

interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  language: string;
  notifications: {
    email: boolean;
    push: boolean;
    sms: boolean;
  };
  privacy: {
    profileVisible: boolean;
    showEmail: boolean;
  };
}

// 用户创建输入
interface CreateUserInput {
  email: string;
  username: string;
  firstName: string;
  lastName: string;
  password: string;
}

// 用户更新输入
type UpdateUserInput = Partial<CreateUserInput> & {
  id: UUID;
  updatedAt: Timestamp;
};
```

### 4.4 API 响应类型

```typescript
// API 响应基础类型
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  meta?: {
    timestamp: Timestamp;
    requestId: UUID;
    version: string;
  };
}

// 分页响应
interface PaginatedResponse<T> extends ApiResponse<{
  items: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}> {}

// 用户相关 API 类型
type GetUserResponse = ApiResponse<User>;
type GetUsersResponse = PaginatedResponse<User>;
type CreateUserResponse = ApiResponse<User>;
type UpdateUserResponse = ApiResponse<User>;
type DeleteUserResponse = ApiResponse<{ deleted: boolean }>;

// 查询参数
interface UserQueryParams {
  page?: number;
  limit?: number;
  search?: string;
  status?: UserStatus['status'];
  role?: UUID;
  sortBy?: 'createdAt' | 'updatedAt' | 'username';
  sortOrder?: 'asc' | 'desc';
}
```

### 4.5 状态机实现

```typescript
// 状态转换规则
type StatusTransition = {
  from: UserStatus['status'];
  to: UserStatus['status'];
  action: string;
  validator?: (user: User, context?: any) => boolean;
};

type StatusTransitions = StatusTransition[];

// 定义允许的状态转换
const userStatusTransitions: StatusTransitions = [
  { from: 'invited', to: 'registered', action: 'register' },
  { from: 'registered', to: 'active', action: 'activate' },
  { from: 'active', to: 'suspended', action: 'suspend' },
  { from: 'suspended', to: 'active', action: 'reactivate' },
  { from: 'active', to: 'deleted', action: 'delete' },
  { from: 'suspended', to: 'deleted', action: 'delete' }
];

// 状态机类型
type StateMachine<T extends { status: any }> = {
  currentState: T['status'];
  transitions: StatusTransitions;
  
  canTransitionTo(state: T['status']): boolean;
  transitionTo(state: T['status']): boolean;
  getAvailableTransitions(): StatusTransition[];
};

// 实现状态机
function createUserStateMachine(user: User): StateMachine<User> {
  return {
    currentState: user.status.status,
    transitions: userStatusTransitions,
    
    canTransitionTo(targetStatus) {
      return this.transitions.some(
        t => t.from === this.currentState && t.to === targetStatus
      );
    },
    
    transitionTo(targetStatus) {
      if (!this.canTransitionTo(targetStatus)) {
        return false;
      }
      this.currentState = targetStatus;
      return true;
    },
    
    getAvailableTransitions() {
      return this.transitions.filter(t => t.from === this.currentState);
    }
  };
}
```

## 5. 练习与作业

### 5.1 基础练习

1. **类型选择练习**
   ```typescript
   // 为以下场景选择合适的类型定义方式：
   // 1. 配置对象（可能被扩展）
   // 2. API 错误码枚举
   // 3. 复杂的响应数据类型
   // 4. 组件 Props 类型
   ```

2. **映射类型练习**
   ```typescript
   // 实现以下工具类型：
   // 1. DeepReadonly<T> - 深度只读
   // 2. OptionalKeys<T> - 获取可选属性的键
   // 3. RequiredKeys<T> - 获取必选属性的键
   ```

### 5.2 进阶练习

3. **复杂条件类型**
   ```typescript
   // 实现 Flatten<T> - 扁平化嵌套数组类型
   type Flatten<T> = /* 你的实现 */;
   
   type Test1 = Flatten<number[][]>; // number[]
   type Test2 = Flatten<string[][][]>; // string[]
   ```

### 5.3 实战作业

4. **电商领域模型**
   - 设计完整的电商系统领域模型
   - 包含商品、订单、用户、支付等实体
   - 实现类型安全的订单状态机
   - 设计完整的 API 响应类型体系

## 6. 最佳实践

### 6.1 命名约定

```typescript
// ✅ 类型命名使用 PascalCase
interface UserService {}
type HttpConfig = {}

// ✅ 泛型参数使用单个大写字母
interface Repository<T> {}
type EventHandler<E> = {}

// ✅ 联合类型使用描述性名称
type Theme = 'light' | 'dark';
type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

// ✅ 工具类型以描述性前缀命名
type Partial<T> = {}
type Required<T> = {}
type Readonly<T> = {}
```

### 6.2 组织结构

```typescript
// ✅ 按功能模块组织
// types/user.ts
export interface User {}
export type UserStatus = {};

// types/auth.ts
export interface AuthToken {}
export type Permission = {};

// ✅ 统一导出
// types/index.ts
export * from './user';
export * from './auth';
```

### 6.3 类型设计原则

```typescript
// ✅ 优先使用接口定义对象结构
interface ApiClient {
  get<T>(url: string): Promise<T>;
  post<T>(url: string, data: any): Promise<T>;
}

// ✅ 使用类型定义复杂类型和工具类型
type ApiResponse<T> = {
  data: T;
  status: number;
};

type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// ✅ 避免过度设计
// 不要为了类型而类型
```

## 7. 课程总结

### 7.1 核心知识点回顾

1. **interface vs type**：理解两者的区别和适用场景
2. **联合与交叉类型**：掌握类型的组合方式
3. **映射类型**：学习类型转换和操作
4. **条件类型**：实现更智能的类型推断

### 7.2 关键概念

- **声明合并**：interface 独有的扩展能力
- **类型收窄**：运行时类型检查与编译时类型推断
- **分布式条件类型**：联合类型的条件处理
- **品牌类型**：创建类型安全的值类型

### 7.3 下节预告

下一课时将学习面向对象与装饰器，包括：
- 类成员修饰符和访问控制
- 抽象类和接口实现
- 装饰器语法和应用场景
- 实现一个封装的请求层服务

### 7.4 扩展阅读

- [TypeScript Handbook - Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
- [TypeScript Handbook - Type Manipulation](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)
- [Effective TypeScript](https://effectivetypescript.com/)