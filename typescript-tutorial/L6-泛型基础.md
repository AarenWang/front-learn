# L6 - 泛型基础

## 本课时目标
- 理解泛型的概念和优势
- 掌握泛型函数、类和接口的编写
- 学会使用泛型约束和默认值
- 实现一个灵活的仓储工具库

## 1. 泛型的基本概念

### 1.1 为什么需要泛型

```typescript
// 问题：没有泛型时的重复代码
function getStringArray(item: string): string[] {
  return [item];
}

function getNumberArray(item: number): number[] {
  return [item];
}

function getBooleanArray(item: boolean): boolean[] {
  return [item];
}

// 使用 any 失去类型安全
function getAnyArray(item: any): any[] {
  return [item];
}

const anyArray = getAnyArray(42);
anyArray.push('hello'); // 类型不安全，可以push字符串

// ✅ 泛型解决方案
function getArray<T>(item: T): T[] {
  return [item];
}

// 类型安全和代码复用
const numberArray = getArray(42); // number[]
const stringArray = getArray('hello'); // string[]
// numberArray.push('hello'); // ❌ 编译错误
```

### 1.2 泛型语法

```typescript
// 泛型函数
function identity<T>(arg: T): T {
  return arg;
}

// 显式指定类型
const result1 = identity<string>('hello');
// const result1: string

// 类型推断
const result2 = identity(42);
// const result2: number

// 多个泛型参数
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

const pairResult = pair('hello', 42);
// const pairResult: [string, number]
```

## 2. 泛型函数

### 2.1 基础泛型函数

```typescript
// 数组操作函数
function getFirstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

function getLastElement<T>(arr: T[]): T | undefined {
  return arr[arr.length - 1];
}

function map<T, U>(arr: T[], fn: (item: T) => U): U[] {
  return arr.map(fn);
}

// 使用
const numbers = [1, 2, 3, 4, 5];
const firstNum = getFirstElement(numbers); // number | undefined
const doubled = map(numbers, x => x * 2); // number[]

const strings = ['hello', 'world'];
const lengths = map(strings, s => s.length); // number[]
```

### 2.2 泛型接口函数

```typescript
// 比较函数接口
interface Comparator<T> {
  (a: T, b: T): number;
}

// 排序函数
function sort<T>(arr: T[], compareFn: Comparator<T>): T[] {
  return [...arr].sort(compareFn);
}

// 使用
const users = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];

const byAge: Comparator<{ name: string; age: number }> = (a, b) => a.age - b.age;
const sortedByAge = sort(users, byAge);

const byName: Comparator<{ name: string; age: number }> = (a, b) => 
  a.name.localeCompare(b.name);
const sortedByName = sort(users, byName);
```

### 2.3 函数重载与泛型

```typescript
// 泛型函数重载
function createArray<T>(length: number, fill: T): T[];
function createArray<T>(length: number, factory: () => T): T[];

function createArray<T>(
  length: number, 
  fillOrFactory: T | (() => T)
): T[] {
  if (typeof fillOrFactory === 'function') {
    const factory = fillOrFactory as () => T;
    return Array.from({ length }, factory);
  }
  return Array(length).fill(fillOrFactory);
}

// 使用
const numberArray = createArray(5, 0); // number[]
const randomNumbers = createArray(5, () => Math.random()); // number[]
const stringArray = createArray(3, 'hello'); // string[]
```

## 3. 泛型类

### 3.1 基础泛型类

```typescript
// 栈类实现
class Stack<T> {
  private items: T[] = [];
  
  push(item: T): void {
    this.items.push(item);
  }
  
  pop(): T | undefined {
    return this.items.pop();
  }
  
  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }
  
  isEmpty(): boolean {
    return this.items.length === 0;
  }
  
  size(): number {
    return this.items.length;
  }
  
  clear(): void {
    this.items = [];
  }
}

// 使用
const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
const num = numberStack.pop(); // number | undefined

const stringStack = new Stack<string>();
stringStack.push('hello');
stringStack.push('world');
const str = stringStack.pop(); // string | undefined
```

### 3.2 复杂泛型类

```typescript
// 事件发射器类
class EventEmitter<T extends Record<string, any[]>> {
  private listeners: {
    [K in keyof T]?: Array<(...args: T[K]) => void>;
  } = {};
  
  on<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(listener);
  }
  
  off<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      const index = eventListeners.indexOf(listener);
      if (index > -1) {
        eventListeners.splice(index, 1);
      }
    }
  }
  
  emit<K extends keyof T>(event: K, ...args: T[K]): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      eventListeners.forEach(listener => listener(...args));
    }
  }
}

// 定义事件类型
interface UserEvents {
  login: [user: { id: string; name: string }];
  logout: [userId: string];
  update: [user: { id: string; changes: Partial<{ name: string; email: string }> }];
}

// 使用
const emitter = new EventEmitter<UserEvents>();

emitter.on('login', (user) => {
  console.log(`${user.name} logged in`);
});

emitter.on('logout', (userId) => {
  console.log(`User ${userId} logged out`);
});

emitter.emit('login', { id: '1', name: 'Alice' });
emitter.emit('logout', '1');
```

### 3.3 泛型约束的类

```typescript
// 需要实现特定接口的泛型类
interface Identifiable {
  id: string;
}

class Repository<T extends Identifiable> {
  private items: Map<string, T> = new Map();
  
  save(item: T): void {
    this.items.set(item.id, item);
  }
  
  findById(id: string): T | undefined {
    return this.items.get(id);
  }
  
  findAll(): T[] {
    return Array.from(this.items.values());
  }
  
  delete(id: string): boolean {
    return this.items.delete(id);
  }
  
  update(id: string, updates: Partial<Omit<T, 'id'>>): boolean {
    const item = this.items.get(id);
    if (item) {
      const updatedItem = { ...item, ...updates } as T;
      this.items.set(id, updatedItem);
      return true;
    }
    return false;
  }
}

// 使用
interface User extends Identifiable {
  id: string;
  name: string;
  email: string;
}

interface Product extends Identifiable {
  id: string;
  name: string;
  price: number;
}

const userRepo = new Repository<User>();
const productRepo = new Repository<Product>();

const user: User = {
  id: '1',
  name: 'Alice',
  email: 'alice@example.com'
};

userRepo.save(user);
const foundUser = userRepo.findById('1'); // User | undefined
```

## 4. 泛型接口

### 4.1 基础泛型接口

```typescript
// HTTP 响应接口
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// 分页响应
interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// 使用
interface User {
  id: string;
  name: string;
}

const userResponse: ApiResponse<User> = {
  data: { id: '1', name: 'Alice' },
  status: 200,
  message: 'Success'
};

const paginatedUsers: PaginatedResponse<User> = {
  data: [
    { id: '1', name: 'Alice' },
    { id: '2', name: 'Bob' }
  ],
  status: 200,
  message: 'Success',
  pagination: {
    page: 1,
    limit: 10,
    total: 2,
    totalPages: 1
  }
};
```

### 4.2 函数类型泛型接口

```typescript
// 数据验证接口
interface Validator<T> {
  validate(value: unknown): value is T;
  getErrorMessage(): string;
}

// 表单字段接口
interface FormField<T> {
  name: string;
  value: T;
  validator: Validator<T>;
  error?: string;
}

// 具体验证器实现
class StringValidator implements Validator<string> {
  constructor(
    private minLength: number = 0,
    private maxLength: number = Infinity,
    private pattern?: RegExp
  ) {}
  
  validate(value: unknown): value is string {
    if (typeof value !== 'string') return false;
    if (value.length < this.minLength) return false;
    if (value.length > this.maxLength) return false;
    if (this.pattern && !this.pattern.test(value)) return false;
    return true;
  }
  
  getErrorMessage(): string {
    const parts = [];
    if (this.minLength > 0) parts.push(`min length ${this.minLength}`);
    if (this.maxLength < Infinity) parts.push(`max length ${this.maxLength}`);
    if (this.pattern) parts.push('must match pattern');
    return `Invalid string${parts.length ? ': ' + parts.join(', ') : ''}`;
  }
}

// 使用
const nameField: FormField<string> = {
  name: 'username',
  value: 'Alice',
  validator: new StringValidator(2, 50)
};

if (!nameField.validator.validate(nameField.value)) {
  nameField.error = nameField.validator.getErrorMessage();
}
```

### 4.3 复杂泛型接口设计

```typescript
// 数据库操作接口
interface DatabaseConnection {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  query<T>(sql: string, params?: any[]): Promise<T[]>;
}

// 仓储接口
interface Repository<T extends { id: string }> {
  create(data: Omit<T, 'id'>): Promise<T>;
  findById(id: string): Promise<T | null>;
  findAll(options?: FindOptions<T>): Promise<T[]>;
  update(id: string, data: Partial<Omit<T, 'id'>>): Promise<T>;
  delete(id: string): Promise<boolean>;
}

interface FindOptions<T> {
  where?: Partial<T>;
  orderBy?: keyof T;
  order?: 'asc' | 'desc';
  limit?: number;
  offset?: number;
}

// 具体实现
class SqliteRepository<T extends { id: string }> implements Repository<T> {
  constructor(
    private db: DatabaseConnection,
    private tableName: string,
    private mapRow: (row: any) => T
  ) {}
  
  async create(data: Omit<T, 'id'>): Promise<T> {
    const id = crypto.randomUUID();
    const item = { id, ...data } as T;
    const columns = Object.keys(item).join(', ');
    const placeholders = Object.keys(item).map(() => '?').join(', ');
    const values = Object.values(item);
    
    await this.db.query(
      `INSERT INTO ${this.tableName} (${columns}) VALUES (${placeholders})`,
      values
    );
    
    return item;
  }
  
  async findById(id: string): Promise<T | null> {
    const rows = await this.db.query<any>(
      `SELECT * FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
    
    return rows.length > 0 ? this.mapRow(rows[0]) : null;
  }
  
  async findAll(options: FindOptions<T> = {}): Promise<T[]> {
    let sql = `SELECT * FROM ${this.tableName}`;
    const params: any[] = [];
    
    if (options.where) {
      const whereConditions = Object.keys(options.where).map(key => {
        params.push((options.where as any)[key]);
        return `${key} = ?`;
      });
      sql += ` WHERE ${whereConditions.join(' AND ')}`;
    }
    
    if (options.orderBy) {
      sql += ` ORDER BY ${String(options.orderBy)} ${options.order || 'asc'}`;
    }
    
    if (options.limit) {
      sql += ` LIMIT ${options.limit}`;
    }
    
    if (options.offset) {
      sql += ` OFFSET ${options.offset}`;
    }
    
    const rows = await this.db.query<any>(sql, params);
    return rows.map(row => this.mapRow(row));
  }
  
  async update(id: string, data: Partial<Omit<T, 'id'>>): Promise<T> {
    const updates = Object.entries(data).map(([key]) => `${key} = ?`).join(', ');
    const values = [...Object.values(data), id];
    
    await this.db.query(
      `UPDATE ${this.tableName} SET ${updates} WHERE id = ?`,
      values
    );
    
    const updated = await this.findById(id);
    if (!updated) throw new Error('Failed to update record');
    return updated;
  }
  
  async delete(id: string): Promise<boolean> {
    const result = await this.db.query(
      `DELETE FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
    return result.length > 0;
  }
}
```

## 5. 泛型约束

### 5.1 基础约束

```typescript
// 约束泛型必须具有特定属性
interface Lengthwise {
  length: number;
}

function getLength<T extends Lengthwise>(arg: T): number {
  return arg.length;
}

// 使用
const stringLength = getLength('hello'); // 5
const arrayLength = getLength([1, 2, 3]); // 3
// getLength(42); // ❌ 错误：number 没有 length 属性

// 约束泛型必须是对象类型
function getProperty<T extends object, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: 'Alice', age: 30 };
const userName = getProperty(user, 'name'); // string
const userAge = getProperty(user, 'age'); // number
// getProperty(user, 'gender'); // ❌ 错误：gender 不是 user 的键
```

### 5.2 多重约束

```typescript
// 多个约束的交集
interface Serializable {
  serialize(): string;
}

interface Validatable {
  validate(): boolean;
}

function processItem<T extends Serializable & Validatable>(item: T): string {
  if (!item.validate()) {
    throw new Error('Invalid item');
  }
  return item.serialize();
}

// 实现
class User implements Serializable, Validatable {
  constructor(
    public name: string,
    public email: string
  ) {}
  
  serialize(): string {
    return JSON.stringify({ name: this.name, email: this.email });
  }
  
  validate(): boolean {
    return this.name.length > 0 && this.email.includes('@');
  }
}

const user = new User('Alice', 'alice@example.com');
const serialized = processItem(user);
```

### 5.3 条件约束

```typescript
// 根据类型约束选择不同的实现
function createInstance<T>(constructor: new (...args: any[]) => T): T {
  return new constructor();
}

// 约束构造函数签名
interface BaseEntity {
  id: string;
  createdAt: Date;
}

function createEntity<T extends BaseEntity>(
  Constructor: new (...args: any[]) => T,
  ...args: any[]
): T {
  const entity = createInstance(Constructor);
  entity.id = crypto.randomUUID();
  entity.createdAt = new Date();
  return entity;
}

// 使用
class Product implements BaseEntity {
  id!: string;
  createdAt!: Date;
  
  constructor(
    public name: string,
    public price: number
  ) {}
}

const product = createEntity(Product, 'Laptop', 999);
console.log(product.id); // UUID
console.log(product.createdAt); // 当前时间
```

## 6. 泛型默认值

### 6.1 基础默认值

```typescript
// 泛型参数默认值
interface Box<T = string> {
  value: T;
}

const stringBox: Box = { value: 'hello' }; // T 默认为 string
const numberBox: Box<number> = { value: 42 }; // 显式指定为 number

// 多个泛型参数的默认值
interface Pair<T = string, U = number> {
  first: T;
  second: U;
}

const defaultPair: Pair = { first: 'hello', second: 42 };
const customPair: Pair<boolean, string> = { first: true, second: 'world' };
```

### 6.2 复杂默认值示例

```typescript
// 默认值可以依赖其他泛型参数
interface ApiResponse<
  T,
  E = { message: string; code: string },
  M = 'success' | 'error'
> {
  data?: T;
  error?: E;
  meta: {
    status: M;
    timestamp: number;
  };
}

// 使用
const successResponse: ApiResponse<{ id: string }> = {
  data: { id: '1' },
  meta: { status: 'success', timestamp: Date.now() }
};

const errorResponse: ApiResponse<null, { message: string }> = {
  error: { message: 'Not found' },
  meta: { status: 'error', timestamp: Date.now() }
};
```

## 7. 实战：仓储工具库

### 7.1 需求分析

创建一个通用的仓储工具库，支持：
- 多种数据源（内存、本地存储、API）
- 类型安全的数据操作
- 查询构建器
- 事件系统

### 7.2 核心接口设计

```typescript
// 仓储核心接口
interface IRepository<T extends { id: string }> {
  // CRUD 操作
  create(data: Omit<T, 'id'>): Promise<T>;
  findById(id: string): Promise<T | null>;
  findAll(query?: Query<T>): Promise<T[]>;
  update(id: string, data: Partial<Omit<T, 'id'>>): Promise<T>;
  delete(id: string): Promise<boolean>;
  
  // 批量操作
  createMany(data: Omit<T, 'id'>[]): Promise<T[]>;
  updateMany(criteria: Partial<T>, data: Partial<Omit<T, 'id'>>): Promise<number>;
  deleteMany(criteria: Partial<T>): Promise<number>;
  
  // 事件系统
  on<K extends keyof RepositoryEvents<T>>(event: K, listener: (...args: RepositoryEvents<T>[K]) => void): void;
  off<K extends keyof RepositoryEvents<T>>(event: K, listener: (...args: RepositoryEvents<T>[K]) => void): void;
}

// 查询接口
interface Query<T> {
  where?: Partial<T>;
  orderBy?: keyof T;
  order?: 'asc' | 'desc';
  limit?: number;
  offset?: number;
  search?: {
    fields: (keyof T)[];
    term: string;
  };
}

// 仓储事件
interface RepositoryEvents<T> {
  created: [item: T];
  updated: [item: T];
  deleted: [id: string, item: T];
  beforeCreate: [data: Omit<T, 'id'>];
  beforeUpdate: [id: string, data: Partial<Omit<T, 'id'>>];
  beforeDelete: [id: string];
}

// 数据源适配器接口
interface DataSourceAdapter<T extends { id: string }> {
  load(): Promise<T[]>;
  save(items: T[]): Promise<void>;
  subscribe(callback: (items: T[]) => void): () => void;
}
```

### 7.3 内存仓储实现

```typescript
class MemoryRepository<T extends { id: string }> implements IRepository<T> {
  private items: Map<string, T> = new Map();
  private eventEmitter = new EventEmitter<RepositoryEvents<T>>();
  
  constructor(private data?: T[]) {
    if (data) {
      data.forEach(item => this.items.set(item.id, item));
    }
  }
  
  async create(data: Omit<T, 'id'>): Promise<T> {
    this.eventEmitter.emit('beforeCreate', data);
    
    const id = crypto.randomUUID();
    const item = { id, ...data } as T;
    this.items.set(id, item);
    
    this.eventEmitter.emit('created', item);
    return item;
  }
  
  async findById(id: string): Promise<T | null> {
    return this.items.get(id) || null;
  }
  
  async findAll(query: Query<T> = {}): Promise<T[]> {
    let items = Array.from(this.items.values());
    
    // WHERE 过滤
    if (query.where) {
      items = this.filterItems(items, query.where);
    }
    
    // 搜索
    if (query.search) {
      items = this.searchItems(items, query.search);
    }
    
    // 排序
    if (query.orderBy) {
      items = this.sortItems(items, query.orderBy, query.order);
    }
    
    // 分页
    if (query.offset) {
      items = items.slice(query.offset);
    }
    
    if (query.limit) {
      items = items.slice(0, query.limit);
    }
    
    return items;
  }
  
  async update(id: string, data: Partial<Omit<T, 'id'>>): Promise<T> {
    const existingItem = this.items.get(id);
    if (!existingItem) {
      throw new Error(`Item with id ${id} not found`);
    }
    
    this.eventEmitter.emit('beforeUpdate', id, data);
    
    const updatedItem = { ...existingItem, ...data } as T;
    this.items.set(id, updatedItem);
    
    this.eventEmitter.emit('updated', updatedItem);
    return updatedItem;
  }
  
  async delete(id: string): Promise<boolean> {
    const item = this.items.get(id);
    if (!item) return false;
    
    this.eventEmitter.emit('beforeDelete', id);
    this.items.delete(id);
    this.eventEmitter.emit('deleted', id, item);
    
    return true;
  }
  
  async createMany(data: Omit<T, 'id'>[]): Promise<T[]> {
    const items = await Promise.all(data.map(d => this.create(d)));
    return items;
  }
  
  async updateMany(criteria: Partial<T>, data: Partial<Omit<T, 'id'>>): Promise<number> {
    const matchingItems = await this.findAll({ where: criteria });
    let updatedCount = 0;
    
    for (const item of matchingItems) {
      await this.update(item.id, data);
      updatedCount++;
    }
    
    return updatedCount;
  }
  
  async deleteMany(criteria: Partial<T>): Promise<number> {
    const matchingItems = await this.findAll({ where: criteria });
    let deletedCount = 0;
    
    for (const item of matchingItems) {
      if (await this.delete(item.id)) {
        deletedCount++;
      }
    }
    
    return deletedCount;
  }
  
  on<K extends keyof RepositoryEvents<T>>(
    event: K, 
    listener: (...args: RepositoryEvents<T>[K]) => void
  ): void {
    this.eventEmitter.on(event, listener);
  }
  
  off<K extends keyof RepositoryEvents<T>>(
    event: K, 
    listener: (...args: RepositoryEvents<T>[K]) => void
  ): void {
    this.eventEmitter.off(event, listener);
  }
  
  // 私有辅助方法
  private filterItems(items: T[], criteria: Partial<T>): T[] {
    return items.filter(item => {
      return Object.entries(criteria).every(([key, value]) => {
        return (item as any)[key] === value;
      });
    });
  }
  
  private searchItems(items: T[], search: Query<T>['search']): T[] {
    if (!search) return items;
    
    return items.filter(item => {
      return search.fields.some(field => {
        const value = String((item as any)[field]);
        return value.toLowerCase().includes(search!.term.toLowerCase());
      });
    });
  }
  
  private sortItems(items: T[], orderBy: keyof T, order: 'asc' | 'desc' = 'asc'): T[] {
    return [...items].sort((a, b) => {
      const aValue = a[orderBy];
      const bValue = b[orderBy];
      
      if (aValue < bValue) return order === 'asc' ? -1 : 1;
      if (aValue > bValue) return order === 'asc' ? 1 : -1;
      return 0;
    });
  }
}
```

### 7.4 本地存储适配器

```typescript
class LocalStorageAdapter<T extends { id: string }> implements DataSourceAdapter<T> {
  constructor(private key: string) {}
  
  async load(): Promise<T[]> {
    const data = localStorage.getItem(this.key);
    return data ? JSON.parse(data) : [];
  }
  
  async save(items: T[]): Promise<void> {
    localStorage.setItem(this.key, JSON.stringify(items));
  }
  
  subscribe(callback: (items: T[]) => void): () => void {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === this.key) {
        const items = e.newValue ? JSON.parse(e.newValue) : [];
        callback(items);
      }
    };
    
    window.addEventListener('storage', handleStorageChange);
    
    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }
}

// 持久化仓储实现
class PersistentRepository<T extends { id: string }> extends MemoryRepository<T> {
  private adapter: DataSourceAdapter<T>;
  private unsubscribe?: () => void;
  
  constructor(
    adapter: DataSourceAdapter<T>,
    data?: T[]
  ) {
    super(data);
    this.adapter = adapter;
    this.init();
  }
  
  private async init() {
    // 加载数据
    const data = await this.adapter.load();
    this['items'] = new Map(data.map(item => [item.id, item]));
    
    // 订阅变化
    this.unsubscribe = this.adapter.subscribe(async (items) => {
      this['items'] = new Map(items.map(item => [item.id, item]));
    });
  }
  
  private async saveToAdapter() {
    const items = Array.from(this['items'].values());
    await this.adapter.save(items);
  }
  
  override async create(data: Omit<T, 'id'>): Promise<T> {
    const item = await super.create(data);
    await this.saveToAdapter();
    return item;
  }
  
  override async update(id: string, data: Partial<Omit<T, 'id'>>): Promise<T> {
    const item = await super.update(id, data);
    await this.saveToAdapter();
    return item;
  }
  
  override async delete(id: string): Promise<boolean> {
    const result = await super.delete(id);
    if (result) {
      await this.saveToAdapter();
    }
    return result;
  }
  
  destroy() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}
```

### 7.5 使用示例

```typescript
// 定义实体类型
interface Todo extends { id: string } {
  title: string;
  completed: boolean;
  createdAt: Date;
  dueDate?: Date;
}

// 创建仓储实例
const todoRepo = new PersistentRepository<Todo>(
  new LocalStorageAdapter<Todo>('todos')
);

// 监听事件
todoRepo.on('created', (todo) => {
  console.log('Todo created:', todo);
});

todoRepo.on('updated', (todo) => {
  console.log('Todo updated:', todo);
});

// 使用仓储
async function manageTodos() {
  // 创建待办事项
  const todo1 = await todoRepo.create({
    title: 'Learn TypeScript',
    completed: false,
    createdAt: new Date()
  });
  
  const todo2 = await todoRepo.create({
    title: 'Build a repository',
    completed: false,
    createdAt: new Date(),
    dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7天后
  });
  
  // 查询所有待办事项
  const allTodos = await todoRepo.findAll();
  console.log('All todos:', allTodos);
  
  // 条件查询
  const incompleteTodos = await todoRepo.findAll({
    where: { completed: false },
    orderBy: 'createdAt',
    order: 'desc'
  });
  
  // 搜索
  const searchResults = await todoRepo.findAll({
    search: {
      fields: ['title'],
      term: 'type'
    }
  });
  
  // 更新
  await todoRepo.update(todo1.id, { completed: true });
  
  // 批量操作
  const updatedCount = await todoRepo.updateMany(
    { completed: false },
    { completed: true }
  );
  console.log(`Updated ${updatedCount} todos`);
  
  // 删除
  await todoRepo.delete(todo2.id);
}

manageTodos().catch(console.error);
```

## 8. 练习与作业

### 8.1 基础练习

1. **泛型函数练习**
   ```typescript
   // 实现：
   // 1. filter<T>() - 数组过滤
   // 2. reduce<T, U>() - 数组规约
   // 3. debounce<T>() - 函数防抖
   ```

2. **泛型类练习**
   ```typescript
   // 实现：
   // 1. Queue<T> - 队列数据结构
   // 2. HashMap<K, V> - 哈希映射
   // 3. TreeNode<T> - 二叉树节点
   ```

### 8.2 进阶练习

3. **泛型约束练习**
   ```typescript
   // 实现：
   // 1. DeepPartial<T> - 深度可选类型
   // 2. RequiredKeys<T> - 获取必选属性
   // 3. Flatten<T> - 扁平化数组类型
   ```

### 8.3 实战作业

4. **完整的仓储工具库**
   - 扩展仓储库支持事务操作
   - 实现查询构建器模式
   - 添加数据验证和序列化
   - 创建 Redis 适配器实现
   - 添加性能监控和日志功能

## 9. 最佳实践

### 9.1 泛型命名约定

```typescript
// ✅ 使用单个大写字母
function identity<T>(arg: T): T { return arg; }

// ✅ 使用描述性泛型名称
interface Repository<TEntity extends { id: string }> {}
class DataSourceAdapter<TRecord> {}

// ✅ 约束泛型要具体
interface Validatable {
  validate(): boolean;
}
function process<T extends Validatable>(item: T) {}

// ❌ 避免过于通用的约束
function badFunction<T extends object>(obj: T) {} // 太宽泛
```

### 9.2 泛型设计原则

```typescript
// ✅ 优先使用泛型而不是重载
function better<T>(value: T): T[] { return [value]; }

// ❌ 避免无意义的重载
// function bad(value: string): string[];
// function bad(value: number): number[];

// ✅ 泛型约束要合理
function create<T extends { id: string }>(data: Omit<T, 'id'>): T {
  return { id: crypto.randomUUID(), ...data } as T;
}

// ✅ 提供合理的默认值
interface Config<T = any> {
  data: T;
  parser?: (data: unknown) => T;
}
```

## 10. 课程总结

### 10.1 核心知识点回顾

1. **泛型基础**：理解泛型的概念和语法
2. **泛型函数**：编写可复用的类型安全函数
3. **泛型类和接口**：创建灵活的数据结构
4. **泛型约束**：限制泛型类型的范围
5. **仓储工具库**：实际应用泛型设计

### 10.2 关键概念

- **类型参数**：T、U、V 等泛型占位符
- **类型推断**：自动推导泛型类型
- **类型约束**：extends 关键字限制
- **条件类型**：基于条件的类型选择

### 10.3 下节预告

下一课时将学习泛型进阶，包括：
- 条件类型的深入应用
- 映射类型的高级用法
- infer 关键字和模式匹配
- 实现 API 响应类型提取工具

### 10.4 扩展阅读

- [TypeScript Handbook - Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
- [TypeScript Generics Explained](https://mariusschulz.com/blog/typescript-generics-explained)
- [Practical Advanced TypeScript](https://github.com/typescript-cheatsheets/react#reacttypescript-cheatsheets)