# L2 - åŸºç¡€ç±»å‹ä¸æ¨æ–­

## ğŸ“š å­¦ä¹ ç›®æ ‡

- æŒæ¡ TypeScript åŸºæœ¬ç±»å‹ç³»ç»Ÿ
- ç†è§£ç±»å‹æ¨æ–­çš„å·¥ä½œåŸç†
- å­¦ä¼šä½¿ç”¨å­—é¢é‡ç±»å‹å’Œè”åˆç±»å‹
- æŒæ¡ä¸¥æ ¼æ¨¡å¼çš„é…ç½®å’Œä½¿ç”¨

## ğŸ”¤ åŸºæœ¬ç±»å‹

### åŸå§‹ç±»å‹

```typescript
// æ•°å­—ç±»å‹
let age: number = 25;
let height: number = 175.5;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;

// å­—ç¬¦ä¸²ç±»å‹
let name: string = "John";
let template: string = `Hello ${name}, you are ${age} years old`;

// å¸ƒå°”ç±»å‹
let isActive: boolean = true;
let isCompleted: boolean = false;

// ç©ºå€¼ç±»å‹
let nothing: void = undefined;
let logMessage = (message: string): void => {
  console.log(message);
};

// null å’Œ undefined
let nullValue: null = null;
let undefinedValue: undefined = undefined;

// never ç±»å‹ - æ°¸è¿œä¸ä¼šè¿”å›çš„å‡½æ•°
function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}
```

### å¯¹è±¡ç±»å‹

```typescript
// æ•°ç»„ç±»å‹
let numbers: number[] = [1, 2, 3, 4, 5];
let strings: Array<string> = ["hello", "world"];
let mixed: (number | string)[] = [1, "two", 3, "four"];

// å…ƒç»„ç±»å‹ - å›ºå®šé•¿åº¦å’Œç±»å‹çš„æ•°ç»„
let tuple: [string, number, boolean] = ["John", 25, true];
let coordinates: [number, number] = [10, 20];

// å¯¹è±¡ç±»å‹
interface User {
  name: string;
  age: number;
  email?: string;  // å¯é€‰å±æ€§
  readonly id: number; // åªè¯»å±æ€§
}

let user: User = {
  name: "Alice",
  age: 30,
  id: 1
  // email æ˜¯å¯é€‰çš„ï¼Œå¯ä»¥ä¸æä¾›
};

// user.id = 2; // é”™è¯¯ï¼id æ˜¯åªè¯»çš„
```

### ç‰¹æ®Šç±»å‹

```typescript
// any ç±»å‹ - ç»•è¿‡ç±»å‹æ£€æŸ¥
let anyValue: any = 42;
anyValue = "hello";
anyValue = { name: "John" };

// unknown ç±»å‹ - æ›´å®‰å…¨çš„ any
let unknownValue: unknown = 42;
// unknownValue.toFixed(2); // é”™è¯¯ï¼éœ€è¦ç±»å‹æ£€æŸ¥

if (typeof unknownValue === "number") {
  unknownValue.toFixed(2); // æ­£ç¡®ï¼
}

// ç±»å‹æ–­è¨€
let someValue: unknown = "hello world";
let strLength: number = (someValue as string).length;
// æˆ–è€…ä½¿ç”¨å°–æ‹¬å·è¯­æ³•ï¼ˆä¸é€‚ç”¨äº JSXï¼‰
let strLength2: number = (<string>someValue).length;
```

## ğŸ¤– ç±»å‹æ¨æ–­

### åŸºç¡€æ¨æ–­

```typescript
// TypeScript ä¼šè‡ªåŠ¨æ¨æ–­ç±»å‹
let x = 3; // æ¨æ–­ä¸º number
let y = "hello"; // æ¨æ–­ä¸º string
let z = [1, 2, 3]; // æ¨æ–­ä¸º number[]
let w = [1, "two", true]; // æ¨æ–­ä¸º (string | number | boolean)[]

// å‡½æ•°è¿”å›å€¼æ¨æ–­
function add(a: number, b: number) {
  return a + b; // æ¨æ–­è¿”å›ç±»å‹ä¸º number
}

function greet(name: string) {
  return `Hello, ${name}!`; // æ¨æ–­è¿”å›ç±»å‹ä¸º string
}
```

### æœ€ä½³é€šç”¨ç±»å‹

```typescript
// TypeScript ä¼šé€‰æ‹©æœ€é€šç”¨çš„ç±»å‹
let array1 = [1, 2, 3]; // number[]
let array2 = [1, "two", 3]; // (string | number)[]
let array3 = [null, 1, "two"]; // (string | number | null)[]

// ä¸Šä¸‹æ–‡æ¨æ–­
window.onmousedown = function(mouseEvent) {
  console.log(mouseEvent.button); // mouseEvent è¢«æ¨æ–­ä¸º MouseEvent
};
```

### æ¨æ–­çš„å±€é™æ€§

```typescript
// éœ€è¦æ˜¾å¼æ³¨è§£çš„æƒ…å†µ
let json = '{"x": 10, "y": 20}';
let coordinates = JSON.parse(json); // æ¨æ–­ä¸º any

// éœ€è¦ç±»å‹æ–­è¨€
interface Point {
  x: number;
  y: number;
}
let point = JSON.parse(json) as Point;

// å‡½æ•°å‚æ•°çš„é»˜è®¤å€¼ä¸ä¼šç”¨äºæ¨æ–­
function createCounter(initialValue = 0) {
  let count = initialValue;
  return {
    increment: () => ++count,
    getCount: () => count
  };
}

const counter = createCounter();
// counter.getCount() è¿”å›ç±»å‹æ¨æ–­ä¸º anyï¼Œéœ€è¦æ˜¾å¼æŒ‡å®š
```

## ğŸ“ å­—é¢é‡ç±»å‹

### å­—ç¬¦ä¸²å­—é¢é‡

```typescript
type Theme = "light" | "dark";
type Status = "pending" | "approved" | "rejected";

let theme: Theme = "light"; // æ­£ç¡®
// let invalidTheme: Theme = "blue"; // é”™è¯¯ï¼

function setStatus(status: Status): void {
  console.log(`Status changed to: ${status}`);
}

setStatus("pending"); // æ­£ç¡®
// setStatus("unknown"); // é”™è¯¯ï¼
```

### æ•°å­—å­—é¢é‡

```typescript
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;
type HTTPMethod = 200 | 201 | 400 | 401 | 404 | 500;

function rollDice(): DiceRoll {
  return Math.floor(Math.random() * 6) + 1 as DiceRoll;
}

function handleResponse(code: HTTPMethod): string {
  switch (code) {
    case 200: return "OK";
    case 201: return "Created";
    case 400: return "Bad Request";
    case 401: return "Unauthorized";
    case 404: return "Not Found";
    case 500: return "Internal Server Error";
    default: 
      // TypeScript çŸ¥é“è¿™é‡Œæ°¸è¿œä¸ä¼šæ‰§è¡Œ
      return "Unknown";
  }
}
```

### å¸ƒå°”å­—é¢é‡

```typescript
type IsEnabled = true;
type IsDisabled = false;

function enableFeature(enabled: IsEnabled): void {
  if (enabled) {
    console.log("Feature enabled");
  }
}
```

## ğŸ¯ è”åˆç±»å‹å’Œäº¤å‰ç±»å‹

### è”åˆç±»å‹ (Union Types)

```typescript
// åŸºæœ¬è”åˆç±»å‹
type StringOrNumber = string | number;
let value: StringOrNumber;

value = "hello";
value = 42;

// å‡½æ•°å‚æ•°è”åˆç±»å‹
function processId(id: string | number): string {
  return id.toString();
}

// è”åˆç±»å‹çš„ç±»å‹å®ˆå«
function padLeft(value: string, padding: string | number): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + value;
  }
  return padding + value;
}

// è”åˆç±»å‹çš„åˆ¤åˆ«å¼
interface LoadingState {
  state: "loading";
}

interface SuccessState {
  state: "success";
  data: any;
}

interface ErrorState {
  state: "error";
  error: string;
}

type ViewState = LoadingState | SuccessState | ErrorState;

function renderView(view: ViewState) {
  switch (view.state) {
    case "loading":
      return "Loading...";
    case "success":
      return `Data: ${JSON.stringify(view.data)}`;
    case "error":
      return `Error: ${view.error}`;
  }
}
```

### äº¤å‰ç±»å‹ (Intersection Types)

```typescript
interface Person {
  name: string;
  age: number;
}

interface Employee {
  companyId: string;
  position: string;
}

// åˆå¹¶ä¸¤ä¸ªæ¥å£
type EmployeePerson = Person & Employee;

let employee: EmployeePerson = {
  name: "John",
  age: 30,
  companyId: "ABC123",
  position: "Developer"
};

// åˆå¹¶å‡½æ•°ç±»å‹
type Func1 = (x: string) => number;
type Func2 = (y: number) => string;
type CombinedFunc = Func1 & Func2;

// è¿™ä¼šäº§ç”Ÿä¸€ä¸ªéœ€è¦åŒæ—¶æ»¡è¶³ä¸¤ç§ç­¾åçš„å‡½æ•°
const combined: CombinedFunc = (x: any) => x;
// é€šå¸¸è”åˆç±»å‹æ›´å®ç”¨
```

## ğŸ›¡ï¸ ä¸¥æ ¼æ¨¡å¼

### å¯ç”¨ä¸¥æ ¼æ¨¡å¼

```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    // æˆ–è€…å•ç‹¬å¯ç”¨å„ä¸ªä¸¥æ ¼é€‰é¡¹
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

### noImplicitAny

```typescript
// ä¸¥æ ¼æ¨¡å¼ä¸‹å¿…é¡»æ˜¾å¼æ³¨è§£ç±»å‹
function calculateTotal(items) { // é”™è¯¯ï¼å‚æ•° 'items' éšå¼å…·æœ‰ 'any' ç±»å‹
  return items.reduce((sum, item) => sum + item.price, 0);
}

// ä¿®å¤ï¼šæ·»åŠ ç±»å‹æ³¨è§£
function calculateTotalFixed(items: Array<{ price: number }>) {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

### strictNullChecks

```typescript
// ä¸¥æ ¼ç©ºå€¼æ£€æŸ¥
function processUser(user: User | null): string {
  // é”™è¯¯ï¼å¯èƒ½ä¸º null
  // return user.name.toUpperCase();
  
  // æ­£ç¡®åšæ³•ï¼šæ£€æŸ¥ null
  if (user === null) {
    return "Guest";
  }
  
  return user.name.toUpperCase();
}

// å¯é€‰é“¾æ“ä½œç¬¦ (?.)
function getUserName(user: User | null): string {
  return user?.name?.toUpperCase() ?? "Guest";
}

// ç©ºå€¼åˆå¹¶æ“ä½œç¬¦ (??)
function getDisplayName(user: User | null): string {
  return user?.displayName ?? user?.name ?? "Anonymous";
}
```

### strictPropertyInitialization

```typescript
class Example {
  // é”™è¯¯ï¼å±æ€§ 'value' æ²¡æœ‰åˆå§‹åŒ–è¡¨è¾¾å¼ï¼Œä¸”æœªåœ¨æ„é€ å‡½æ•°ä¸­æ˜ç¡®èµ‹å€¼
  value: string;

  // æ­£ç¡®ï¼šåœ¨æ„é€ å‡½æ•°ä¸­åˆå§‹åŒ–
  initialized: string;

  // æ­£ç¡®ï¼šä½¿ç”¨é»˜è®¤å€¼
  withDefault: number = 0;

  // æ­£ç¡®ï¼šä½¿ç”¨ definite assignment assertion
  definitelyAssigned!: string;

  constructor() {
    this.initialized = "initialized";
  }
}
```

## ğŸ“‹ å®è·µç»ƒä¹ ï¼šé‡æ„è¡¨å•æ ¡éªŒ

### ç»ƒä¹  1: è¡¨å•å­—æ®µç±»å‹å®šä¹‰

```typescript
// å®šä¹‰è¡¨å•å­—æ®µç±»å‹
type FieldType = "text" | "email" | "password" | "number" | "tel";

interface FormField {
  name: string;
  type: FieldType;
  label: string;
  required: boolean;
  placeholder?: string;
  maxLength?: number;
  minLength?: number;
  pattern?: string;
}

interface FormData {
  [fieldName: string]: string | number | undefined;
}

type ValidationResult = {
  isValid: boolean;
  errors: string[];
};

type Validator = (value: string) => ValidationResult;
```

### ç»ƒä¹  2: æ ¡éªŒå™¨å®ç°

```typescript
// åˆ›å»ºæ ¡éªŒå™¨å‡½æ•°
const createRequiredValidator = (fieldName: string): Validator => {
  return (value: string): ValidationResult => {
    const isValid = value.trim().length > 0;
    return {
      isValid,
      errors: isValid ? [] : [`${fieldName} is required`]
    };
  };
};

const createEmailValidator = (): Validator => {
  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return (value: string): ValidationResult => {
    const isValid = !value || emailPattern.test(value);
    return {
      isValid,
      errors: isValid ? [] : ["Invalid email format"]
    };
  };
};

const createLengthValidator = (
  min: number,
  max?: number,
  fieldName: string
): Validator => {
  return (value: string): ValidationResult => {
    const length = value.length;
    const errors: string[] = [];
    
    if (length < min) {
      errors.push(`${fieldName} must be at least ${min} characters`);
    }
    
    if (max && length > max) {
      errors.push(`${fieldName} must not exceed ${max} characters`);
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  };
};
```

### ç»ƒä¹  3: è¡¨å•æ ¡éªŒå™¨ç»„åˆ

```typescript
class FormValidator {
  private fields: FormField[] = [];
  
  addField(field: FormField): this {
    this.fields.push(field);
    return this;
  }
  
  getValidatorsForField(field: FormField): Validator[] {
    const validators: Validator[] = [];
    
    if (field.required) {
      validators.push(createRequiredValidator(field.label));
    }
    
    if (field.type === "email") {
      validators.push(createEmailValidator());
    }
    
    if (field.minLength) {
      validators.push(
        createLengthValidator(
          field.minLength,
          field.maxLength,
          field.label
        )
      );
    }
    
    return validators;
  }
  
  validate(formData: FormData): { isValid: boolean; fieldErrors: Record<string, string[]> } {
    const fieldErrors: Record<string, string[]> = {};
    let isValid = true;
    
    for (const field of this.fields) {
      const value = String(formData[field.name] || "");
      const validators = this.getValidatorsForField(field);
      
      const allErrors: string[] = [];
      for (const validator of validators) {
        const result = validator(value);
        if (!result.isValid) {
          allErrors.push(...result.errors);
        }
      }
      
      if (allErrors.length > 0) {
        fieldErrors[field.name] = allErrors;
        isValid = false;
      }
    }
    
    return { isValid, fieldErrors };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const validator = new FormValidator()
  .addField({
    name: "username",
    type: "text",
    label: "Username",
    required: true,
    minLength: 3,
    maxLength: 20
  })
  .addField({
    name: "email",
    type: "email",
    label: "Email",
    required: true
  })
  .addField({
    name: "password",
    type: "password",
    label: "Password",
    required: true,
    minLength: 8
  });

const formData: FormData = {
  username: "john",
  email: "john@example.com",
  password: "password123"
};

const result = validator.validate(formData);
console.log(result);
```

## ğŸ¯ æœ¬è¯¾æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **åŸºæœ¬ç±»å‹**: æŒæ¡åŸå§‹ç±»å‹ã€å¯¹è±¡ç±»å‹å’Œç‰¹æ®Šç±»å‹
2. **ç±»å‹æ¨æ–­**: ç†è§£ TypeScript è‡ªåŠ¨æ¨æ–­çš„æœºåˆ¶å’Œé™åˆ¶
3. **å­—é¢é‡ç±»å‹**: ä½¿ç”¨å­—é¢é‡ç±»å‹åˆ›å»ºæ›´ç²¾ç¡®çš„ç±»å‹çº¦æŸ
4. **è”åˆä¸äº¤å‰**: ç†è§£ç±»å‹ç»„åˆçš„æ¦‚å¿µå’Œåº”ç”¨åœºæ™¯
5. **ä¸¥æ ¼æ¨¡å¼**: æŒæ¡ä¸¥æ ¼æ¨¡å¼é…ç½®å’Œæœ€ä½³å®è·µ

### ç±»å‹ç³»ç»Ÿé€ŸæŸ¥

```typescript
// åŸºç¡€ç±»å‹
number, string, boolean, null, undefined, void, never, any, unknown

// å¤åˆç±»å‹
Array<T>, T[], [T, U] // å…ƒç»„
T | U // è”åˆç±»å‹
T & U // äº¤å‰ç±»å‹
"literal" // å­—é¢é‡ç±»å‹

// å·¥å…·ç±»å‹
Partial<T>, Required<T>, Readonly<T>
Record<K, T>, Pick<T, K>, Omit<T, K>
```

## ğŸ“– æ¨èé˜…è¯»

- [TypeScript Handbook - Basic Types](https://www.typescriptlang.org/docs/handbook/basic-types.html)
- [TypeScript Handbook - Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)
- [TypeScript Handbook - Literal Types](https://www.typescriptlang.org/docs/handbook/literal-types.html)

---

**ä¸Šä¸€è¯¾**: [L1 - å·¥å…·é“¾åˆä½“éªŒ](./L1-å·¥å…·é“¾åˆä½“éªŒ.md)  
**ä¸‹ä¸€è¯¾**: [L3 - å‡½æ•°ä¸ this](./L3-å‡½æ•°ä¸this.md)