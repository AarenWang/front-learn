# L9 - 类型守卫与控制流

## 本课时目标
- 掌握类型守卫的概念和实现
- 理解可辨识联合类型的设计模式
- 学会利用 TypeScript 的控制流分析
- 实现一个类型安全的表单状态机

## 1. 类型守卫基础

### 1.1 类型谓词

```typescript
// 基础类型守卫
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value);
}

function isBoolean(value: unknown): value is boolean {
  return typeof value === 'boolean';
}

// 使用类型守卫
function processValue(value: unknown): string {
  if (isString(value)) {
    // 在这个分支中，value 被推断为 string
    return value.toUpperCase();
  } else if (isNumber(value)) {
    // 在这个分支中，value 被推断为 number
    return value.toFixed(2);
  } else if (isBoolean(value)) {
    // 在这个分支中，value 被推断为 boolean
    return value ? 'true' : 'false';
  }
  return 'unknown';
}

// 对象类型守卫
interface Cat {
  type: 'cat';
  name: string;
  meow(): void;
}

interface Dog {
  type: 'dog';
  name: string;
  bark(): void;
}

function isCat(animal: Cat | Dog): animal is Cat {
  return (animal as Cat).type === 'cat';
}

function isDog(animal: Cat | Dog): animal is Dog {
  return (animal as Dog).type === 'dog';
}
```

### 1.2 instanceof 类型守卫

```typescript
// 类的类型守卫
class Error {
  constructor(public message: string, public code?: string) {}
}

class NetworkError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public url: string
  ) {
    super(message);
  }
}

class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public value: any
  ) {
    super(message);
  }
}

function handleError(error: Error): string {
  if (error instanceof NetworkError) {
    // error 被推断为 NetworkError
    return `Network Error: ${error.message} (${error.statusCode}) at ${error.url}`;
  } else if (error instanceof ValidationError) {
    // error 被推断为 ValidationError
    return `Validation Error: ${error.message} in field ${error.field}`;
  }
  
  return `General Error: ${error.message}`;
}

// 数组类型守卫
function isArray(value: unknown): value is any[] {
  return Array.isArray(value);
}

function isStringArray(value: unknown): value is string[] {
  return Array.isArray(value) && value.every(isString);
}

// 使用
function processArray(data: unknown): number {
  if (isStringArray(data)) {
    // data 被推断为 string[]
    return data.length;
  }
  return 0;
}
```

### 1.3 in 操作符类型守卫

```typescript
// 基础 in 操作符
interface Square {
  kind: 'square';
  size: number;
}

interface Circle {
  kind: 'circle';
  radius: number;
}

interface Rectangle {
  kind: 'rectangle';
  width: number;
  height: number;
}

type Shape = Square | Circle | Rectangle;

function getArea(shape: Shape): number {
  if ('size' in shape) {
    // shape 被推断为 Square
    return shape.size * shape.size;
  } else if ('radius' in shape) {
    // shape 被推断为 Circle
    return Math.PI * shape.radius * shape.radius;
  } else {
    // shape 被推断为 Rectangle
    return shape.width * shape.height;
  }
}

// 复杂的 in 操作符守卫
interface HasId {
  id: string;
}

interface HasName {
  name: string;
}

interface HasEmail {
  email: string;
}

type User = HasId & HasName & HasEmail;
type Product = HasId & HasName;
type Order = HasId;

function getDisplayName(entity: User | Product | Order): string {
  if ('name' in entity) {
    // entity 被推断为 User | Product
    return entity.name;
  } else {
    // entity 被推断为 Order
    return `Order #${entity.id}`;
  }
}
```

## 2. 可辨识联合类型

### 2.1 基础可辨识联合

```typescript
// 定义可辨识联合
interface LoadingState {
  status: 'loading';
  message?: string;
}

interface SuccessState<T> {
  status: 'success';
  data: T;
}

interface ErrorState {
  status: 'error';
  error: {
    message: string;
    code?: string;
  };
}

type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;

// 使用可辨识联合
function renderAsyncState<T>(state: AsyncState<T>): string {
  switch (state.status) {
    case 'loading':
      return `Loading...${state.message ? ` ${state.message}` : ''}`;
    case 'success':
      return `Success: ${JSON.stringify(state.data)}`;
    case 'error':
      return `Error: ${state.error.message}`;
    default:
      // TypeScript 确保 default 分支永远不会被执行
      const _exhaustiveCheck: never = state;
      return _exhaustiveCheck;
  }
}

// 处理 API 响应
interface ApiResponse {
  success: boolean;
  data?: any;
  error?: string;
}

type ApiState = 
  | { type: 'pending' }
  | { type: 'success'; payload: any }
  | { type: 'error'; error: string };

function handleApiResponse(response: ApiResponse): ApiState {
  if (response.success && response.data) {
    return { type: 'success', payload: response.data };
  } else if (!response.success) {
    return { type: 'error', error: response.error || 'Unknown error' };
  }
  return { type: 'pending' };
}
```

### 2.2 复杂可辨识联合设计

```typescript
// 文件系统示例
type FileNode = 
  | { type: 'file'; name: string; size: number; content: string }
  | { type: 'directory'; name: string; children: FileNode[] }
  | { type: 'symlink'; name: string; target: string };

function processFileNode(node: FileNode): void {
  switch (node.type) {
    case 'file':
      console.log(`File: ${node.name} (${node.size} bytes)`);
      break;
    case 'directory':
      console.log(`Directory: ${node.name} (${node.children.length} items)`);
      node.children.forEach(processFileNode);
      break;
    case 'symlink':
      console.log(`Symlink: ${node.name} -> ${node.target}`);
      break;
  }
}

// 用户状态机
type UserEvent =
  | { type: 'register'; data: { name: string; email: string } }
  | { type: 'activate' }
  | { type: 'deactivate' }
  | { type: 'update'; data: Partial<{ name: string; email: string }> }
  | { type: 'delete' };

type UserState =
  | { status: 'pending' }
  | { status: 'active'; data: { name: string; email: string } }
  | { status: 'inactive'; data: { name: string; email: string } }
  | { status: 'deleted' };

function userReducer(state: UserState, event: UserEvent): UserState {
  switch (state.status) {
    case 'pending':
      if (event.type === 'register') {
        return {
          status: 'inactive',
          data: { name: event.data.name, email: event.data.email }
        };
      }
      return state;
      
    case 'inactive':
      if (event.type === 'activate') {
        return { ...state, status: 'active' };
      }
      if (event.type === 'update') {
        return {
          ...state,
          data: { ...state.data, ...event.data }
        };
      }
      if (event.type === 'delete') {
        return { status: 'deleted' };
      }
      return state;
      
    case 'active':
      if (event.type === 'deactivate') {
        return { ...state, status: 'inactive' };
      }
      if (event.type === 'update') {
        return {
          ...state,
          data: { ...state.data, ...event.data }
        };
      }
      if (event.type === 'delete') {
        return { status: 'deleted' };
      }
      return state;
      
    case 'deleted':
      return state;
      
    default:
      const _exhaustiveCheck: never = state;
      return _exhaustiveCheck;
  }
}
```

### 2.3 可辨识联合模式匹配

```typescript
// 模式匹配辅助函数
function match<T, R>(
  value: T,
  patterns: { [K in keyof T]: (value: Extract<T, { type: K }>) => R }
): R {
  const typeKey = (value as any).type;
  const pattern = patterns[typeKey as keyof T];
  if (!pattern) {
    throw new Error(`No pattern for type: ${typeKey}`);
  }
  return pattern(value as any);
}

// 使用模式匹配
type MathOperation = 
  | { type: 'add'; left: number; right: number }
  | { type: 'subtract'; left: number; right: number }
  | { type: 'multiply'; left: number; right: number }
  | { type: 'divide'; left: number; right: number };

function evaluate(operation: MathOperation): number {
  return match(operation, {
    add: ({ left, right }) => left + right,
    subtract: ({ left, right }) => left - right,
    multiply: ({ left, right }) => left * right,
    divide: ({ left, right }) => {
      if (right === 0) throw new Error('Division by zero');
      return left / right;
    }
  });
}

// 高级模式匹配
type Result<T, E = Error> =
  | { type: 'ok'; value: T }
  | { type: 'error'; error: E };

class Result<T, E = Error> {
  private constructor(private value: Result<T, E>) {}
  
  static ok<T>(value: T): Result<T, never> {
    return new Result({ type: 'ok', value });
  }
  
  static error<E>(error: E): Result<never, E> {
    return new Result({ type: 'error', error });
  }
  
  map<U>(fn: (value: T) => U): Result<U, E> {
    return this.value.type === 'ok'
      ? Result.ok(fn(this.value.value))
      : Result.error(this.value.error);
  }
  
  flatMap<U>(fn: (value: T) => Result<U, E>): Result<U, E> {
    return this.value.type === 'ok'
      ? fn(this.value.value)
      : Result.error(this.value.error);
  }
  
  match<U>(patterns: {
    ok: (value: T) => U;
    error: (error: E) => U;
  }): U {
    return this.value.type === 'ok'
      ? patterns.ok(this.value.value)
      : patterns.error(this.value.error);
  }
}
```

## 3. 控制流分析

### 3.1 类型收窄

```typescript
// 真值性收窄
function processNullable(value: string | null | undefined): string {
  if (value) {
    // value 被收窄为 string
    return value.toUpperCase();
  }
  return 'default';
}

// 等式检查收窄
function processStatus(status: 'loading' | 'success' | 'error'): string {
  if (status === 'loading') {
    // status 被收窄为 'loading'
    return 'Loading...';
  } else if (status === 'success') {
    // status 被收窄为 'success'
    return 'Success!';
  } else {
    // status 被收窄为 'error'
    return 'Error occurred';
  }
}

// typeof 收窄
function processPrimitive(value: string | number | boolean): string {
  switch (typeof value) {
    case 'string':
      return `String: ${value}`;
    case 'number':
      return `Number: ${value.toFixed(2)}`;
    case 'boolean':
      return `Boolean: ${value}`;
    default:
      const _exhaustiveCheck: never = value;
      return _exhaustiveCheck;
  }
}

// 自定义类型守卫收窄
interface A { a: string; }
interface B { b: number; }
type AB = A | B;

function isA(obj: AB): obj is A {
  return 'a' in obj;
}

function processAB(obj: AB): string {
  if (isA(obj)) {
    // obj 被收窄为 A
    return obj.a;
  } else {
    // obj 被收窄为 B
    return obj.b.toString();
  }
}
```

### 3.2 控制流语句

```typescript
// if-else 链式收窄
function getUserDescription(user: { name?: string; email?: string }): string {
  if (user.name && user.email) {
    // 两者都存在
    return `${user.name} <${user.email}>`;
  } else if (user.name) {
    // 只有 name
    return user.name;
  } else if (user.email) {
    // 只有 email
    return `<${user.email}>`;
  } else {
    // 都不存在
    return 'Unknown User';
  }
}

// switch 语句收窄
function getDayType(day: number): 'weekday' | 'weekend' | 'invalid' {
  switch (day) {
    case 0:
    case 6:
      return 'weekend';
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return 'weekday';
    default:
      return 'invalid';
  }
}

// 循环中的类型收窄
function findFirstString(strings: (string | null)[]): string | null {
  for (const str of strings) {
    if (str !== null) {
      // str 被收窄为 string
      return str;
    }
  }
  return null;
}

// 数组方法中的类型收窄
function getValidNumbers(values: (number | string | null)[]): number[] {
  return values
    .filter((value): value is number => 
      typeof value === 'number' && !isNaN(value)
    )
    .filter(num => num > 0);
}
```

### 3.3 控制流分析与断言

```typescript
// 明确赋值断言
let username: string;
let age: number;

function initializeUser() {
  username = 'Alice';
  age = 30;
}

function printUser(): void {
  initializeUser();
  // 如果没有调用 initializeUser，这里会报错
  console.log(`${username} is ${age} years old}`);
}

// 非空断言操作符 (!)
function processElement(element: HTMLElement | null): void {
  // 告诉 TypeScript element 不是 null
  console.log(element!.textContent);
}

function getFirstElement(arr: string[]): string {
  // 告诉 TypeScript 第一个元素肯定存在
  return arr[0]!;
}

// 类型断言
interface UnknownShape {
  type: unknown;
  properties: unknown;
}

function castToKnownShape(shape: UnknownShape): { type: string; properties: Record<string, any> } {
  return shape as { type: string; properties: Record<string, any> };
}

// 双重断言
function processValue(value: unknown): string {
  return value as any as string;
}

// 满足类型守卫
interface Validatable {
  validate(): boolean;
}

function ensureValid<T extends Validatable>(obj: T): asserts obj is T & { validated: true } {
  if (!obj.validate()) {
    throw new Error('Validation failed');
  }
  
  (obj as any).validated = true;
}

class User implements Validatable {
  constructor(
    public name: string,
    public email: string
  ) {}
  
  validate(): boolean {
    return this.name.length > 0 && this.email.includes('@');
  }
}

function processUser(user: User): void {
  ensureValid(user);
  // user 现在被推断为 User & { validated: true }
  console.log(`Validated user: ${user.name}`);
}
```

## 4. 实战：表单状态机类型守卫

### 4.1 需求分析

创建一个类型安全的表单系统，支持：
- 多步骤表单流程
- 表单验证状态
- 字段级别的类型守卫
- 状态转换验证

### 4.2 表单状态定义

```typescript
// 表单字段类型
interface FormField<T = any> {
  name: string;
  value: T;
  error?: string;
  touched: boolean;
  dirty: boolean;
  validating: boolean;
}

// 表单状态类型
type FormStatus = 'idle' | 'validating' | 'valid' | 'invalid' | 'submitting' | 'submitted' | 'error';

interface FormState<T extends Record<string, any> = Record<string, any>> {
  fields: {
    [K in keyof T]: FormField<T[K]>;
  };
  status: FormStatus;
  submitCount: number;
  isDirty: boolean;
  isValid: boolean;
  submitError?: string;
}

// 表单事件类型
type FormEvent<T extends Record<string, any> = Record<string, any>> =
  | { type: 'field_change'; field: keyof T; value: T[keyof T] }
  | { type: 'field_touch'; field: keyof T }
  | { type: 'field_blur'; field: keyof T }
  | { type: 'field_validate'; field: keyof T }
  | { type: 'validate_all' }
  | { type: 'submit' }
  | { type: 'submit_success' }
  | { type: 'submit_error'; error: string }
  | { type: 'reset' };
```

### 4.3 验证器类型守卫

```typescript
// 验证器接口
interface Validator<T = any> {
  validate(value: T): Promise<string | null> | string | null;
  message?: string;
}

// 内置验证器
const validators = {
  required: (message = 'This field is required'): Validator => ({
    validate: (value) => {
      if (value === null || value === undefined || value === '') {
        return message;
      }
      return null;
    },
    message
  }),
  
  email: (message = 'Please enter a valid email'): Validator<string> => ({
    validate: (value) => {
      if (!value) return null;
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(value) ? null : message;
    },
    message
  }),
  
  minLength: (min: number, message?: string): Validator<string> => ({
    validate: (value) => {
      if (!value) return null;
      return value.length >= min ? null : (message || `Must be at least ${min} characters`);
    },
    message: message || `Must be at least ${min} characters`
  }),
  
  maxLength: (max: number, message?: string): Validator<string> => ({
    validate: (value) => {
      if (!value) return null;
      return value.length <= max ? null : (message || `Must be at most ${max} characters`);
    },
    message: message || `Must be at most ${max} characters`
  }),
  
  pattern: (regex: RegExp, message = 'Invalid format'): Validator<string> => ({
    validate: (value) => {
      if (!value) return null;
      return regex.test(value) ? null : message;
    },
    message
  }),
  
  async: <T>(
    validator: (value: T) => Promise<string | null>,
    message?: string
  ): Validator<T> => ({
    validate: validator,
    message
  })
};

// 字段验证配置
type FieldValidation<T> = Validator<T> | Validator<T>[];

// 表单验证配置
type FormValidation<T extends Record<string, any>> = {
  [K in keyof T]?: FieldValidation<T[K]>;
};

// 验证器工具函数
class ValidatorUtils {
  static async runValidator<T>(
    value: T,
    validator: Validator<T>
  ): Promise<string | null> {
    const result = await validator.validate(value);
    return result || null;
  }
  
  static async runValidators<T>(
    value: T,
    validators: Validator<T>[]
  ): Promise<string | null> {
    for (const validator of validators) {
      const error = await this.runValidator(value, validator);
      if (error) return error;
    }
    return null;
  }
  
  static isValidator<T>(obj: any): obj is Validator<T> {
    return obj && typeof obj === 'object' && typeof obj.validate === 'function';
  }
  
  static isValidatorArray<T>(obj: any): obj is Validator<T>[] {
    return Array.isArray(obj) && obj.every(this.isValidator);
  }
}
```

### 4.4 表单状态机实现

```typescript
// 表单状态机类
class FormStateMachine<T extends Record<string, any>> {
  private state: FormState<T>;
  private validation: FormValidation<T>;
  private listeners: { [K in FormEvent['type']]?: Array<(event: Extract<FormEvent<T>, { type: K }>) => void> } = {};
  
  constructor(
    initialValues: T,
    validation: FormValidation<T> = {}
  ) {
    this.validation = validation;
    this.state = this.createInitialState(initialValues);
  }
  
  // 创建初始状态
  private createInitialState(values: T): FormState<T> {
    const fields = {} as { [K in keyof T]: FormField<T[K]> };
    
    for (const key in values) {
      fields[key] = {
        name: key,
        value: values[key],
        touched: false,
        dirty: false,
        validating: false
      };
    }
    
    return {
      fields,
      status: 'idle',
      submitCount: 0,
      isDirty: false,
      isValid: true
    };
  }
  
  // 获取当前状态
  public getState(): FormState<T> {
    return { ...this.state };
  }
  
  // 类型守卫方法
  public isStatus(status: FormStatus): boolean {
    return this.state.status === status;
  }
  
  public isFieldValid<K extends keyof T>(field: K): boolean {
    const fieldState = this.state.fields[field];
    return !fieldState.error && fieldState.touched;
  }
  
  public isFieldDirty<K extends keyof T>(field: K): boolean {
    return this.state.fields[field].dirty;
  }
  
  public hasFieldError<K extends keyof T>(field: K): boolean {
    return !!this.state.fields[field].error;
  }
  
  public isFormValid(): boolean {
    return this.state.isValid && this.everyFieldTouched();
  }
  
  public isFormDirty(): boolean {
    return this.state.isDirty;
  }
  
  // 字段访问器
  public getFieldValue<K extends keyof T>(field: K): T[K] {
    return this.state.fields[field].value;
  }
  
  public getFieldError<K extends keyof T>(field: K): string | undefined {
    return this.state.fields[field].error;
  }
  
  public setFieldValue<K extends keyof T>(field: K, value: T[K]): void {
    const currentValue = this.state.fields[field].value;
    if (currentValue !== value) {
      this.dispatch({ type: 'field_change', field, value });
    }
  }
  
  // 事件处理
  public async dispatch(event: FormEvent<T>): Promise<void> {
    switch (event.type) {
      case 'field_change':
        await this.handleFieldChange(event.field, event.value);
        break;
        
      case 'field_touch':
        this.handleFieldTouch(event.field);
        break;
        
      case 'field_blur':
        await this.handleFieldBlur(event.field);
        break;
        
      case 'field_validate':
        await this.handleFieldValidate(event.field);
        break;
        
      case 'validate_all':
        await this.handleValidateAll();
        break;
        
      case 'submit':
        await this.handleSubmit();
        break;
        
      case 'submit_success':
        this.handleSubmitSuccess();
        break;
        
      case 'submit_error':
        this.handleSubmitError(event.error);
        break;
        
      case 'reset':
        this.handleReset();
        break;
    }
    
    this.notifyListeners(event);
  }
  
  // 处理字段变化
  private async handleFieldChange<K extends keyof T>(field: K, value: T[K]): Promise<void> {
    const currentField = this.state.fields[field];
    const isDirty = value !== (this.state.fields[field] as any).initialValue;
    
    this.state = {
      ...this.state,
      fields: {
        ...this.state.fields,
        [field]: {
          ...currentField,
          value,
          dirty: isDirty,
          error: undefined
        }
      },
      isDirty: this.calculateIsDirty()
    };
    
    // 如果字段有验证器且已经被触碰过，立即验证
    if (currentField.touched && this.validation[field]) {
      await this.validateField(field);
    }
  }
  
  // 处理字段触碰
  private handleFieldTouch<K extends keyof T>(field: K): void {
    const currentField = this.state.fields[field];
    
    if (!currentField.touched) {
      this.state = {
        ...this.state,
        fields: {
          ...this.state.fields,
          [field]: {
            ...currentField,
            touched: true
          }
        }
      };
    }
  }
  
  // 处理字段失焦
  private async handleFieldBlur<K extends keyof T>(field: K): Promise<void> {
    await this.handleFieldTouch(field);
    await this.handleFieldValidate(field);
  }
  
  // 处理字段验证
  private async handleFieldValidate<K extends keyof T>(field: K): Promise<void> {
    const fieldValidators = this.validation[field];
    if (!fieldValidators) return;
    
    const currentField = this.state.fields[field];
    const value = currentField.value;
    
    this.state = {
      ...this.state,
      fields: {
        ...this.state.fields,
        [field]: {
          ...currentField,
          validating: true,
          error: undefined
        }
      }
    };
    
    try {
      let error: string | null = null;
      
      if (ValidatorUtils.isValidator(fieldValidators)) {
        error = await ValidatorUtils.runValidator(value, fieldValidators);
      } else if (ValidatorUtils.isValidatorArray(fieldValidators)) {
        error = await ValidatorUtils.runValidators(value, fieldValidators);
      }
      
      this.state = {
        ...this.state,
        fields: {
          ...this.state.fields,
          [field]: {
            ...currentField,
            validating: false,
            error: error || undefined
          }
        },
        isValid: this.calculateIsValid()
      };
      
    } catch (err) {
      this.state = {
        ...this.state,
        fields: {
          ...this.state.fields,
          [field]: {
            ...currentField,
            validating: false,
            error: 'Validation error'
          }
        },
        isValid: this.calculateIsValid()
      };
    }
  }
  
  // 处理全部验证
  private async handleValidateAll(): Promise<void> {
    const fieldNames = Object.keys(this.state.fields) as (keyof T)[];
    
    for (const field of fieldNames) {
      await this.handleFieldTouch(field);
      await this.handleFieldValidate(field);
    }
  }
  
  // 处理提交
  private async handleSubmit(): Promise<void> {
    await this.handleValidateAll();
    
    if (!this.state.isValid) {
      this.state = {
        ...this.state,
        status: 'invalid'
      };
      return;
    }
    
    this.state = {
      ...this.state,
      status: 'submitting',
      submitCount: this.state.submitCount + 1
    };
  }
  
  // 处理提交成功
  private handleSubmitSuccess(): void {
    this.state = {
      ...this.state,
      status: 'submitted',
      submitError: undefined
    };
  }
  
  // 处理提交错误
  private handleSubmitError(error: string): void {
    this.state = {
      ...this.state,
      status: 'error',
      submitError: error
    };
  }
  
  // 处理重置
  private handleReset(): void {
    const initialValues = Object.fromEntries(
      Object.entries(this.state.fields).map(([key, field]) => [
        key,
        (field as any).initialValue
      ])
    ) as T;
    
    this.state = this.createInitialState(initialValues);
  }
  
  // 计算辅助方法
  private calculateIsDirty(): boolean {
    return Object.values(this.state.fields).some(field => field.dirty);
  }
  
  private calculateIsValid(): boolean {
    return Object.values(this.state.fields).every(field => !field.error);
  }
  
  private everyFieldTouched(): boolean {
    return Object.values(this.state.fields).every(field => field.touched);
  }
  
  // 事件监听器
  public on<K extends FormEvent['type']>(
    eventType: K,
    listener: (event: Extract<FormEvent<T>, { type: K }>) => void
  ): () => void {
    if (!this.listeners[eventType]) {
      this.listeners[eventType] = [];
    }
    
    this.listeners[eventType]!.push(listener);
    
    // 返回取消订阅函数
    return () => {
      const listeners = this.listeners[eventType];
      if (listeners) {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
    };
  }
  
  private notifyListeners(event: FormEvent<T>): void {
    const listeners = this.listeners[event.type];
    if (listeners) {
      listeners.forEach(listener => listener(event as any));
    }
  }
}
```

### 4.5 实际使用示例

```typescript
// 定义表单数据类型
interface LoginForm {
  email: string;
  password: string;
  rememberMe: boolean;
}

// 创建表单状态机
function createLoginForm() {
  const form = new FormStateMachine<LoginForm>(
    {
      email: '',
      password: '',
      rememberMe: false
    },
    {
      email: [
        validators.required('Email is required'),
        validators.email('Please enter a valid email')
      ],
      password: [
        validators.required('Password is required'),
        validators.minLength(8, 'Password must be at least 8 characters')
      ]
    }
  );
  
  // 监听状态变化
  form.on('field_change', (event) => {
    console.log(`Field ${event.field} changed to:`, event.value);
  });
  
  form.on('submit', async () => {
    if (form.isStatus('submitting')) {
      try {
        // 模拟 API 调用
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const formData = {
          email: form.getFieldValue('email'),
          password: form.getFieldValue('password'),
          rememberMe: form.getFieldValue('rememberMe')
        };
        
        console.log('Submitting form:', formData);
        
        form.dispatch({ type: 'submit_success' });
      } catch (error) {
        form.dispatch({ type: 'submit_error', error: 'Login failed' });
      }
    }
  });
  
  return form;
}

// 使用表单
async function demonstrateForm() {
  const loginForm = createLoginForm();
  
  // 设置字段值
  loginForm.setFieldValue('email', 'user@example.com');
  loginForm.setFieldValue('password', 'password123');
  
  // 验证所有字段
  await loginForm.dispatch({ type: 'validate_all' });
  
  console.log('Form is valid:', loginForm.isFormValid());
  console.log('Email field is valid:', loginForm.isFieldValid('email'));
  console.log('Email error:', loginForm.getFieldError('email'));
  
  // 提交表单
  if (loginForm.isFormValid()) {
    await loginForm.dispatch({ type: 'submit' });
  }
  
  // 检查最终状态
  console.log('Final status:', loginForm.getState().status);
}

demonstrateForm();

// React Hook 封装示例
function useForm<T extends Record<string, any>>(
  initialValues: T,
  validation?: FormValidation<T>
) {
  const [formMachine] = useState(() => 
    new FormStateMachine(initialValues, validation)
  );
  
  const [state, setState] = useState(() => formMachine.getState());
  
  useEffect(() => {
    const unsubscribe = formMachine.on('*', () => {
      setState(formMachine.getState());
    });
    
    return unsubscribe;
  }, [formMachine]);
  
  return {
    values: Object.fromEntries(
      Object.entries(state.fields).map(([key, field]) => [key, field.value])
    ) as T,
    errors: Object.fromEntries(
      Object.entries(state.fields)
        .filter(([_, field]) => field.error)
        .map(([key, field]) => [key, field.error])
    ) as Partial<Record<keyof T, string>>,
    touched: Object.fromEntries(
      Object.entries(state.fields).map(([key, field]) => [key, field.touched])
    ) as Partial<Record<keyof T, boolean>>,
    setValue: <K extends keyof T>(field: K, value: T[K]) => 
      formMachine.setFieldValue(field, value),
    onBlur: <K extends keyof T>(field: K) => 
      formMachine.dispatch({ type: 'field_blur', field }),
    onSubmit: () => formMachine.dispatch({ type: 'submit' }),
    isValid: state.isValid,
    isSubmitting: state.status === 'submitting',
    submitError: state.submitError
  };
}
```

## 5. 练习与作业

### 5.1 基础练习

1. **类型谓词练习**
   ```typescript
   // 实现以下类型守卫：
   // 1. isObject - 判断是否为对象
   // 2. isDate - 判断是否为日期对象
   // 3. isPromise - 判断是否为 Promise
   ```

2. **可辨识联合练习**
   ```typescript
   // 设计一个树形结构的可辨识联合：
   // 包含：文件、目录、符号链接
   // 实现遍历和统计功能
   ```

### 5.2 进阶练习

3. **状态机设计**
   ```typescript
   // 设计一个网络请求状态机：
   // 状态：idle、loading、success、error
   // 支持重试和取消功能
   // 包含完整的类型守卫
   ```

### 5.3 实战作业

4. **完整的表单系统**
   - 实现动态字段添加/删除
   - 支持条件验证（字段间依赖）
   - 添加表单数据持久化
   - 实现表单向导（多步骤）
   - 创建 React 组件库

## 6. 最佳实践

### 6.1 类型守卫设计原则

```typescript
// ✅ 类型守卫应该有清晰的命名
function isString(value: unknown): value is string { /* ... */ }
function isValidEmail(email: unknown): email is string { /* ... */ }

// ✅ 类型守卫应该保守（宁可 false 也不误判）
function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value) && isFinite(value);
}

// ✅ 复杂的类型守卫可以组合使用
function isValidUser(obj: unknown): obj is User {
  return isObject(obj) && 
         isString((obj as any).name) && 
         isEmail((obj as any).email);
}

// ❌ 避免过于宽泛的类型守卫
// function isAnything(value: unknown): value is any { return true; }
```

### 6.2 可辨识联合设计

```typescript
// ✅ 使用字符串字面量作为判别式
type Result<T, E> = 
  | { success: true; data: T }
  | { success: false; error: E };

// ✅ 判别式字段应该放在最前面
// ✅ 使用描述性的类型名
type NetworkState = 
  | { status: 'idle' }
  | { status: 'loading'; startedAt: Date }
  | { status: 'success'; data: any; receivedAt: Date }
  | { status: 'error'; error: Error; failedAt: Date };

// ✅ 确保所有变体都被处理
function processState(state: NetworkState): string {
  switch (state.status) {
    case 'idle': return 'Idle';
    case 'loading': return 'Loading...';
    case 'success': return `Success: ${state.data}`;
    case 'error': return `Error: ${state.error.message}`;
    // default 分支会检查是否遗漏了某些状态
    default: {
      const _exhaustiveCheck: never = state;
      return _exhaustiveCheck;
    }
  }
}
```

## 7. 课程总结

### 7.1 核心知识点回顾

1. **类型守卫**：类型谓词、instanceof、in 操作符
2. **可辨识联合**：判别式字段和模式匹配
3. **控制流分析**：类型收窄和断言机制
4. **表单状态机**：类型安全的状态管理

### 7.2 关键概念

- **类型收窄**：在条件分支中自动推断更具体的类型
- **模式匹配**：基于结构进行类型选择
- **控制流分析**：TypeScript 静态分析代码流程
- **状态机**：严格的状态转换和类型安全

### 7.3 下节预告

下一课时将学习异步与并发类型，包括：
- Promise 类型系统和 Awaited 工具类型
- 异步函数的类型推断
- 并发操作和竞态条件处理
- 实现批处理调度器类型定义

### 7.4 扩展阅读

- [TypeScript Handbook - Type Guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
- [TypeScript Handbook - Discriminated Unions](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions)
- [Effective TypeScript - Type Guards](https://effectivetypescript.com/2020/10/27/type-guards/)