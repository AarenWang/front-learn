<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dyson Sphere Canvas Sketch</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #05060d;
      --fg: #dfe8ff;
      --accent: #1db6ff;
      --accent-2: #ffda5a;
      --soft: #6fd6ff44;
      --panel: #82f3ff22;
      --panel-2: #ffd54f22;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 30% 30%, #0a1226, #060712 55%, #02030a);
      color: var(--fg);
      display: grid;
      place-items: center;
      min-height: 100vh;
      padding: 24px;
      gap: 24px;
    }

    .panel {
      width: min(1200px, 100%);
      background: #0a0d1a;
      border: 1px solid #1e2640;
      border-radius: 18px;
      box-shadow: 0 20px 80px #000a;
      overflow: hidden;
    }

    header {
      padding: 16px 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(120deg, #0f1a2e, #0a0d1a 50%, #0c1222);
      border-bottom: 1px solid #1e2640;
    }

    header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.3px;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    button {
      background: #11233f;
      color: var(--fg);
      border: 1px solid #2b3d60;
      border-radius: 12px;
      padding: 8px 14px;
      font-weight: 600;
      letter-spacing: 0.2px;
      cursor: pointer;
      transition: all 160ms ease;
    }

    button:hover { border-color: #3ea6ff; box-shadow: 0 0 0 1px #3ea6ff44 inset, 0 10px 30px #0008; }
    button:active { transform: translateY(1px) scale(0.99); }

    canvas {
      display: block;
      width: 100%;
      height: clamp(420px, 70vh, 820px);
      background: radial-gradient(ellipse at 50% 50%, #040816, #01030c 70%, #000);
    }

    footer {
      padding: 14px 18px;
      border-top: 1px solid #1e2640;
      background: #0b0e19;
      font-size: 13px;
      letter-spacing: 0.1px;
      color: #a9b7d9;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div class="panel">
    <header>
      <h1>Dyson Sphere — Canvas Study</h1>
      <div class="controls">
        <button id="schemeA">方案 A · 蓝金</button>
        <button id="schemeB">方案 B · 紫青</button>
      </div>
    </header>
    <canvas id="scene" width="1200" height="720" aria-label="Dyson Sphere canvas"></canvas>
    <footer>
      <span>灵感来源：戴森球概念图，用 Canvas 重新绘制光泽、面板和卫星。</span>
      <span id="hint">点击按钮切换配色方案。</span>
    </footer>
  </div>

  <script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    let viewWidth = 0;
    let viewHeight = 0;
    let dpr = 1;

    const schemes = {
      A: {
        glow: '#2de3ff',
        glow2: '#ffd45b',
        surface: ['#0e4b8f', '#0c1c3f'],
        lattice: '#1ec7ff55',
        lattice2: '#ffd45b55',
        halo: '#1d6bff',
        satellites: '#8fe6ff',
      },
      B: {
        glow: '#5af5ff',
        glow2: '#ff7cf3',
        surface: ['#12325c', '#0c182d'],
        lattice: '#63ffe655',
        lattice2: '#ff7cf355',
        halo: '#5ec7ff',
        satellites: '#c7f3ff',
      }
    };

    let current = 'A';
    let tick = 0;
    const stars = Array.from({ length: 240 }, () => ({
      x: Math.random(),
      y: Math.random(),
      r: Math.random() * 1.2 + 0.2,
      a: Math.random() * Math.PI * 2,
      twinkle: Math.random() * 0.5 + 0.5,
    }));

    function resize() {
      const rect = canvas.getBoundingClientRect();
      dpr = window.devicePixelRatio || 1;
      viewWidth = rect.width;
      viewHeight = rect.height;
      canvas.width = viewWidth * dpr;
      canvas.height = viewHeight * dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
    }
    resize();
    window.addEventListener('resize', resize);

    function drawStarfield() {
      const width = viewWidth;
      const height = viewHeight;
      ctx.save();
      ctx.fillStyle = '#01040c';
      ctx.fillRect(0, 0, width, height);
      stars.forEach((s, i) => {
        const alpha = 0.3 + Math.sin(tick * 0.02 + s.a) * 0.2;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * s.twinkle})`;
        const x = s.x * width;
        const y = s.y * height;
        ctx.beginPath();
        ctx.arc(x, y, s.r, 0, Math.PI * 2);
        ctx.fill();
        if (i % 17 === 0) {
          ctx.strokeStyle = `rgba(110, 180, 255, ${alpha * 0.5})`;
          ctx.beginPath();
          ctx.arc(x, y, s.r * 3, 0, Math.PI * 2);
          ctx.stroke();
        }
      });
      ctx.restore();
    }

    function drawSphere({ glow, glow2, surface, lattice, lattice2, halo, satellites }) {
      const w = viewWidth;
      const h = viewHeight;
      const cx = w / 2;
      const cy = h / 2;
      const radius = Math.min(w, h) * 0.28;

      ctx.save();
      ctx.translate(cx, cy);

      // halo
      const haloGrad = ctx.createRadialGradient(0, 0, radius * 0.9, 0, 0, radius * 1.45);
      haloGrad.addColorStop(0, `${halo}55`);
      haloGrad.addColorStop(1, '#0000');
      ctx.fillStyle = haloGrad;
      ctx.beginPath();
      ctx.arc(0, 0, radius * 1.45, 0, Math.PI * 2);
      ctx.fill();

      // body
      const bodyGrad = ctx.createRadialGradient(-radius * 0.2, -radius * 0.2, radius * 0.1, 0, 0, radius * 1.1);
      bodyGrad.addColorStop(0, surface[0]);
      bodyGrad.addColorStop(1, surface[1]);
      ctx.fillStyle = bodyGrad;
      ctx.shadowColor = `${glow}55`;
      ctx.shadowBlur = 30;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();

      // patch (the yellow luminous matrix)
      const patchRadius = radius * 0.48;
      const patchGrad = ctx.createRadialGradient(radius * 0.25, -radius * 0.15, patchRadius * 0.1, radius * 0.25, -radius * 0.15, patchRadius * 1.1);
      patchGrad.addColorStop(0, `${glow2}`);
      patchGrad.addColorStop(1, `${glow2}00`);
      ctx.fillStyle = patchGrad;
      ctx.beginPath();
      ctx.arc(radius * 0.25, -radius * 0.15, patchRadius, 0, Math.PI * 2);
      ctx.fill();

      // hexagonal panel hints
      const panelCount = 90;
      ctx.lineWidth = 1.2;
      for (let i = 0; i < panelCount; i++) {
        const a = (i / panelCount) * Math.PI * 2 + tick * 0.002;
        const dist = radius * 0.4 + Math.sin(i * 0.6 + tick * 0.01) * 6;
        const size = 10 + Math.sin(i + tick * 0.03) * 4;
        const x = Math.cos(a) * dist;
        const y = Math.sin(a) * dist * 0.75;
        ctx.strokeStyle = i % 3 === 0 ? lattice2 : lattice;
        ctx.beginPath();
        for (let j = 0; j < 6; j++) {
          const ang = a + j * Math.PI / 3;
          const px = x + Math.cos(ang) * size;
          const py = y + Math.sin(ang) * size * 0.75;
          if (j === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
      }

      // banding / orbital rings
      const ringCount = 6;
      for (let i = 0; i < ringCount; i++) {
        const rot = (i / ringCount) * Math.PI * 2 + tick * 0.005;
        ctx.save();
        ctx.rotate(rot);
        ctx.strokeStyle = `${glow}66`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, radius * 1.05, radius * 0.45 + i * 4, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      // satellites / thrusters
      const satCount = 22;
      for (let i = 0; i < satCount; i++) {
        const a = (i / satCount) * Math.PI * 2 + tick * 0.01;
        const r = radius * 1.05 + Math.sin(tick * 0.02 + i) * 6;
        const x = Math.cos(a) * r;
        const y = Math.sin(a) * r * 0.72;
        ctx.fillStyle = `${satellites}`;
        ctx.beginPath();
        ctx.arc(x, y, 4 + (i % 3 === 0 ? 2 : 0), 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = `${glow}44`;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x * 1.08, y * 1.05);
        ctx.stroke();
      }

      // highlight gloss
      const glossGrad = ctx.createRadialGradient(-radius * 0.5, -radius * 0.5, 10, 0, 0, radius * 1.1);
      glossGrad.addColorStop(0, `${glow}aa`);
      glossGrad.addColorStop(1, '#ffffff00');
      ctx.fillStyle = glossGrad;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function draw() {
      const colors = schemes[current];
      drawStarfield();
      drawSphere(colors);
      tick += 1;
      requestAnimationFrame(draw);
    }

    document.getElementById('schemeA').addEventListener('click', () => {
      current = 'A';
      document.getElementById('hint').textContent = '方案 A：蓝色背景 + 金色能量矩阵';
    });
    document.getElementById('schemeB').addEventListener('click', () => {
      current = 'B';
      document.getElementById('hint').textContent = '方案 B：紫青星云 + 粉色面板高光';
    });

    draw();
  </script>
</body>
</html>
